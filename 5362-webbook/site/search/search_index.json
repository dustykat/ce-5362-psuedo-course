{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"ce5362-swmodeling-lesson-1/","text":"CE 5362 Surface Water Modeling Lesson 1: Introduction These web pages are built using JupyterLab, in most of my pages, there are two special code blocks, the one below to make markup cells properly left-align, and the one at the bottom which identifies the server that last ran the notebook. You need not understand the script in the cells, just a warning of their presence. %%html <style> table {margin-left: 0 !important;} </style> table {margin-left: 0 !important;} Description: The course prepares engineers to practice hydrologic and hydraulic modeling in one-dimensional unsteady conditions; and in higher spatial dimensions (2D/3D) using custom-written and professional software tools. Integration of simulation tools to examine complex systems is emphasized. Syllabus: The syllabus is located at http://54.243.252.9/ce-5362-psuedo-course/0-Syllabus/ce5362-swmodeling-2021-1.html Content Server(s): The primary course content server is http://54.243.252.9/ce-5362-psuedo-course/ The development course content server (used as a backup) is https://github.com/dustykat/ce-5362-webroot Learning Management System (LMS) Blackboard https://ttu.blackboard.com/webapps/login Software JupyterLab as implemented in Anaconda for custom-written programs You can run these on your laptops, or on an AWS Lightsail Instance as you prefer. The instructor runs his examples on either an AWS Lightsail Instance (or sometimes on a Raspberry Pi) SWMM You can install and run on your laptops, or on an AWS Lightsail Instance as you prefer. The instructor will run SWMM on an AWS Lightsail Instance EFDC and/or SToRM (to be determined as course progresses) These are clock-cycle hogs; you can install and run on your laptops, or on an AWS Lightsail Instance as you prefer. I am going to use an AWS Lightsail Instance Textbook: none, but there are readings located at: http://54.243.252.9/ce-5362-psuedo-course/3-Readings/ which will be referenced during the course. Surface Water Modeling - What's the Point?: Consider an excerpt from a recent e-mail: Surface Water Hydrologist (Entry-Level), Tampa, FL 21-02-TPA01 All interested applicants must apply online at https://www.interacareers.com/jobDesc.asp?JobID=215 INTERA is seeking a Surface Water / Groundwater Hydrologist who is skilled using and developing modern flow and transport modeling tools in our Tampa, Florida, office. The candidate should have a BS or MS in engineering that focuses on water resources or a related field. The chosen candidate will conduct data processing , analysis , and visualization to support surface water , groundwater , and integrated modeling projects throughout the state of Florida and will develop hydrologic and hydraulic models under the supervision of a professional engineer. This is an excellent opportunity to advance your technical skills and career while collaborating with some of the industry\u2019s top talent. As a company wholly dedicated to providing safe and technically sound solutions that exceed our clients\u2019 expectations, we are looking for self-starters who face all project challenges head-on with expertise and commitment. INTERA\u2019s corporate vision is Delivering Excellence with Every Solution, and we invite all interested candidates to apply if you can embody this on both a personal and professional level. Essential Duties and Responsibilities This position requires an interest in the design and calibration of surface water , groundwater, and integrated models and a strong background in programming and geographic information systems (GIS); strong report writing, and communication skills are also essential. The candidate will perform data visualization with large data sets by developing scripts in Python or R and develop spatial plots of data in GIS . The position will include documentation of all work products in technical reports and presentations. Additional duties include developing models and alternative simulations under the supervision of a professional engineer. The candidate must be able to work independently and have experience working with other modelers, engineers, and well-educated clients. Desired Education and Skills - BS or MS in Civil/Environmental Engineering with an emphasis on hydrology or a related field - Experience analyzing large data sets programmatically using R or Python - Experience with Geographic Information System (GIS) programs such as ArcMap - Excellent written and verbal communication skills - Experience with HSPF , ICPRv4 , HEC-RAS , the suite of HEC-RAS tools, and MODFLOW is preferred - Programming using R or Python Required Qualifications - Must be able to exercise professional judgement, perform QA/QC on data sets, and examine data with a critical eye - Excellent time management skills in organizing, planning, and prioritizing work - Must be reliable and conscientious and have the ability to maintain effective and positive work relationships with others, be a cooperative team player and work with a wide variety of people. - Excellent verbal and written communication skills are required About INTERA & Our Benefits Our employees say that what they value most at INTERA is our corporate culture\u2014because not only do we believe that our people are our most important asset, we embody it. As an employee-owned company, we are invested in not only providing a good work-life balance with flexible schedules and telecommuting opportunities, but we offer generous benefits packages (we even have a 0-dollar cost health plan), bonus eligibilities, tuition reimbursements, and more. These are some of the reasons why many of our employees have spent 10 to 25 years or more at INTERA. We love what we do and it shows. So join us today because INTERA has a reputation of excellence, leaves no room for politics, and empowers all of our employees to accomplish their best! The Point There are jobs in the field, so you should have some background in the general topic -- notice the advertisement mentions specific software -- we will use similar software to explore the concepts in these commercial products; its not hard to translate skills - but we have to have them in the first place! There is a fair amount of on-line how-to https://www.epa.gov/waterdata/surface-water-quality-modeling-training but this alone just makes you dangerous, here we will try to get an understanding of the complexity of the models, so we can trick them as needed (trick in the good sense; make them work for us!) What is Modeling? Modeling is the art of representing reality in a simplified form, sufficient to answer questions about that reality What is a Model? There are many definitions, a few are: A model is a simplification of reality that duplicates the excitation-response of the real system but is faster, smaller, or more practical to study than the real system. A mathematical model is composed of mathematical expressions quantifying fundamental physical principles (force, energy, mass, etc.). These expressions are adapted and simplified in each case to the special features of the problem to be tackled. A model is any device that represents an approximation of a field situation. There are several categories of models: Physical models such as laboratory sand tanks, flumes, pipe networks, porous columns, batch reactors, and pilot plants are used to directly simulate various conditions anticipated in full scale settings. Physical models tend to be the most costly to build from scratch, but many questions cannot be answered without these kind of model Analog models such as electric circuit analogs or Hele-Shaw analogs are used to indirectly simulate field conditions by direct simulation in a domain analogous to the real setting. Analog computers are quite rare today, but in the 1960's were a principal tool in modeling and were used in aerospace as well as mundane civil engineering applications. A laboratory mouse used to test medicine doses (usually for lethality) is an example of an analog model for human testing. Bear (1972), Chapter 11 provides an excellent background on analog models. The treatment is mostly aimed at porous medium flow, but the concepts are generic. The book has some nice photographs of electric-analog computers (which are rare today). Mathematical models indirectly simulate field conditions by solution of a governing equation thought to represent the system, along with auxiliary equations that describe the boundary and forcing conditions. These physics and chemical relationships are represented as sets of algebraic equations. Conversion from physics to the computer is via finite-difference, finite-element, finite-volume analysis. Particle tracking is an alternate approach. Mathematical models are solved analytically or numerically -- both solutions may require a computer. The set of commands used to solve a mathematical problem on a computer is the program or code. The code is generic, whereas a model is comprised of boundary and initial conditions, a computational grid, material properties on that grid, and forcing terms. Thus a model is both the data and code, whereas the code alone is just a tool waiting for use. Another kind of model is a statistical (or data model) model that relates observations to excitations without necessarily attempting to relate underlying physics of the problem (Machine Learning; Neural Networks, Regression Trees, Support Vector Machines are these kind of models). All the kinds of models are useful and appropriate tools in their various applications. Lesson 1: Workshop Getting us into a common computing environment: I am going to use Amazon Web Services Lightsail (Virtual Private Server) Instances: They are low cost (~24 USD/month or less) compute servers for running models on a remote AWS maintained machine. You can try AWS yourself, or do everything on a laptop. If it's a Apple Macintosh you might have a better experience with AWS. Install a Remote Desktop Protocol Client You will use a Windows Server environment on your AWS instance. You need a RDP client to connect to the server and get a GUI. If you have Windows RDP is built-in, if you are a Mac or Linux user you will need to obtain a useable client. The workshop will demonstrate using a Macintosh, then using a Raspberry Pi running Ubuntu Linux to demonstrate the procedure. Build an AWS Lightsail Instance/Install Anaconda I already made a video on this part, so I will just play it https://www.youtube.com/watch?v=s8CJKq2Rvgg&feature=youtu.be Install SWMM I will do this live, so I have a current copy (also to see if it works on AWS as expected). The other special script block is below! # Script block to identify host, user, and kernel import sys ! hostname ! whoami print(sys.executable) print(sys.version) print(sys.version_info) # Script block to left align Markdown Tables atomickitty.aws antares /opt/jupyterhub/bin/python3 3.6.9 (default, Oct 8 2020, 12:12:24) [GCC 8.4.0] sys.version_info(major=3, minor=6, micro=9, releaselevel='final', serial=0)","title":"Lesson 1 Introduction"},{"location":"ce5362-swmodeling-lesson-1/#ce-5362-surface-water-modeling","text":"","title":"CE 5362 Surface Water Modeling"},{"location":"ce5362-swmodeling-lesson-1/#lesson-1-introduction","text":"These web pages are built using JupyterLab, in most of my pages, there are two special code blocks, the one below to make markup cells properly left-align, and the one at the bottom which identifies the server that last ran the notebook. You need not understand the script in the cells, just a warning of their presence. %%html <style> table {margin-left: 0 !important;} </style> table {margin-left: 0 !important;}","title":"Lesson 1: Introduction"},{"location":"ce5362-swmodeling-lesson-1/#description","text":"The course prepares engineers to practice hydrologic and hydraulic modeling in one-dimensional unsteady conditions; and in higher spatial dimensions (2D/3D) using custom-written and professional software tools. Integration of simulation tools to examine complex systems is emphasized.","title":"Description:"},{"location":"ce5362-swmodeling-lesson-1/#syllabus","text":"The syllabus is located at http://54.243.252.9/ce-5362-psuedo-course/0-Syllabus/ce5362-swmodeling-2021-1.html","title":"Syllabus:"},{"location":"ce5362-swmodeling-lesson-1/#content-servers","text":"The primary course content server is http://54.243.252.9/ce-5362-psuedo-course/ The development course content server (used as a backup) is https://github.com/dustykat/ce-5362-webroot","title":"Content Server(s):"},{"location":"ce5362-swmodeling-lesson-1/#learning-management-system-lms","text":"Blackboard https://ttu.blackboard.com/webapps/login","title":"Learning Management System (LMS)"},{"location":"ce5362-swmodeling-lesson-1/#software","text":"JupyterLab as implemented in Anaconda for custom-written programs You can run these on your laptops, or on an AWS Lightsail Instance as you prefer. The instructor runs his examples on either an AWS Lightsail Instance (or sometimes on a Raspberry Pi) SWMM You can install and run on your laptops, or on an AWS Lightsail Instance as you prefer. The instructor will run SWMM on an AWS Lightsail Instance EFDC and/or SToRM (to be determined as course progresses) These are clock-cycle hogs; you can install and run on your laptops, or on an AWS Lightsail Instance as you prefer. I am going to use an AWS Lightsail Instance","title":"Software"},{"location":"ce5362-swmodeling-lesson-1/#textbook","text":"none, but there are readings located at: http://54.243.252.9/ce-5362-psuedo-course/3-Readings/ which will be referenced during the course.","title":"Textbook:"},{"location":"ce5362-swmodeling-lesson-1/#surface-water-modeling-whats-the-point","text":"Consider an excerpt from a recent e-mail: Surface Water Hydrologist (Entry-Level), Tampa, FL 21-02-TPA01 All interested applicants must apply online at https://www.interacareers.com/jobDesc.asp?JobID=215 INTERA is seeking a Surface Water / Groundwater Hydrologist who is skilled using and developing modern flow and transport modeling tools in our Tampa, Florida, office. The candidate should have a BS or MS in engineering that focuses on water resources or a related field. The chosen candidate will conduct data processing , analysis , and visualization to support surface water , groundwater , and integrated modeling projects throughout the state of Florida and will develop hydrologic and hydraulic models under the supervision of a professional engineer. This is an excellent opportunity to advance your technical skills and career while collaborating with some of the industry\u2019s top talent. As a company wholly dedicated to providing safe and technically sound solutions that exceed our clients\u2019 expectations, we are looking for self-starters who face all project challenges head-on with expertise and commitment. INTERA\u2019s corporate vision is Delivering Excellence with Every Solution, and we invite all interested candidates to apply if you can embody this on both a personal and professional level. Essential Duties and Responsibilities This position requires an interest in the design and calibration of surface water , groundwater, and integrated models and a strong background in programming and geographic information systems (GIS); strong report writing, and communication skills are also essential. The candidate will perform data visualization with large data sets by developing scripts in Python or R and develop spatial plots of data in GIS . The position will include documentation of all work products in technical reports and presentations. Additional duties include developing models and alternative simulations under the supervision of a professional engineer. The candidate must be able to work independently and have experience working with other modelers, engineers, and well-educated clients. Desired Education and Skills - BS or MS in Civil/Environmental Engineering with an emphasis on hydrology or a related field - Experience analyzing large data sets programmatically using R or Python - Experience with Geographic Information System (GIS) programs such as ArcMap - Excellent written and verbal communication skills - Experience with HSPF , ICPRv4 , HEC-RAS , the suite of HEC-RAS tools, and MODFLOW is preferred - Programming using R or Python Required Qualifications - Must be able to exercise professional judgement, perform QA/QC on data sets, and examine data with a critical eye - Excellent time management skills in organizing, planning, and prioritizing work - Must be reliable and conscientious and have the ability to maintain effective and positive work relationships with others, be a cooperative team player and work with a wide variety of people. - Excellent verbal and written communication skills are required About INTERA & Our Benefits Our employees say that what they value most at INTERA is our corporate culture\u2014because not only do we believe that our people are our most important asset, we embody it. As an employee-owned company, we are invested in not only providing a good work-life balance with flexible schedules and telecommuting opportunities, but we offer generous benefits packages (we even have a 0-dollar cost health plan), bonus eligibilities, tuition reimbursements, and more. These are some of the reasons why many of our employees have spent 10 to 25 years or more at INTERA. We love what we do and it shows. So join us today because INTERA has a reputation of excellence, leaves no room for politics, and empowers all of our employees to accomplish their best!","title":"Surface Water Modeling - What's the Point?:"},{"location":"ce5362-swmodeling-lesson-1/#the-point","text":"There are jobs in the field, so you should have some background in the general topic -- notice the advertisement mentions specific software -- we will use similar software to explore the concepts in these commercial products; its not hard to translate skills - but we have to have them in the first place! There is a fair amount of on-line how-to https://www.epa.gov/waterdata/surface-water-quality-modeling-training but this alone just makes you dangerous, here we will try to get an understanding of the complexity of the models, so we can trick them as needed (trick in the good sense; make them work for us!)","title":"The Point"},{"location":"ce5362-swmodeling-lesson-1/#what-is-modeling","text":"Modeling is the art of representing reality in a simplified form, sufficient to answer questions about that reality","title":"What is Modeling?"},{"location":"ce5362-swmodeling-lesson-1/#what-is-a-model","text":"There are many definitions, a few are: A model is a simplification of reality that duplicates the excitation-response of the real system but is faster, smaller, or more practical to study than the real system. A mathematical model is composed of mathematical expressions quantifying fundamental physical principles (force, energy, mass, etc.). These expressions are adapted and simplified in each case to the special features of the problem to be tackled. A model is any device that represents an approximation of a field situation. There are several categories of models: Physical models such as laboratory sand tanks, flumes, pipe networks, porous columns, batch reactors, and pilot plants are used to directly simulate various conditions anticipated in full scale settings. Physical models tend to be the most costly to build from scratch, but many questions cannot be answered without these kind of model Analog models such as electric circuit analogs or Hele-Shaw analogs are used to indirectly simulate field conditions by direct simulation in a domain analogous to the real setting. Analog computers are quite rare today, but in the 1960's were a principal tool in modeling and were used in aerospace as well as mundane civil engineering applications. A laboratory mouse used to test medicine doses (usually for lethality) is an example of an analog model for human testing. Bear (1972), Chapter 11 provides an excellent background on analog models. The treatment is mostly aimed at porous medium flow, but the concepts are generic. The book has some nice photographs of electric-analog computers (which are rare today). Mathematical models indirectly simulate field conditions by solution of a governing equation thought to represent the system, along with auxiliary equations that describe the boundary and forcing conditions. These physics and chemical relationships are represented as sets of algebraic equations. Conversion from physics to the computer is via finite-difference, finite-element, finite-volume analysis. Particle tracking is an alternate approach. Mathematical models are solved analytically or numerically -- both solutions may require a computer. The set of commands used to solve a mathematical problem on a computer is the program or code. The code is generic, whereas a model is comprised of boundary and initial conditions, a computational grid, material properties on that grid, and forcing terms. Thus a model is both the data and code, whereas the code alone is just a tool waiting for use. Another kind of model is a statistical (or data model) model that relates observations to excitations without necessarily attempting to relate underlying physics of the problem (Machine Learning; Neural Networks, Regression Trees, Support Vector Machines are these kind of models). All the kinds of models are useful and appropriate tools in their various applications.","title":"What is a Model?"},{"location":"ce5362-swmodeling-lesson-1/#lesson-1-workshop","text":"Getting us into a common computing environment: I am going to use Amazon Web Services Lightsail (Virtual Private Server) Instances: They are low cost (~24 USD/month or less) compute servers for running models on a remote AWS maintained machine. You can try AWS yourself, or do everything on a laptop. If it's a Apple Macintosh you might have a better experience with AWS.","title":"Lesson 1: Workshop"},{"location":"ce5362-swmodeling-lesson-1/#install-a-remote-desktop-protocol-client","text":"You will use a Windows Server environment on your AWS instance. You need a RDP client to connect to the server and get a GUI. If you have Windows RDP is built-in, if you are a Mac or Linux user you will need to obtain a useable client. The workshop will demonstrate using a Macintosh, then using a Raspberry Pi running Ubuntu Linux to demonstrate the procedure.","title":"Install a Remote Desktop Protocol Client"},{"location":"ce5362-swmodeling-lesson-1/#build-an-aws-lightsail-instanceinstall-anaconda","text":"I already made a video on this part, so I will just play it https://www.youtube.com/watch?v=s8CJKq2Rvgg&feature=youtu.be","title":"Build an AWS Lightsail Instance/Install Anaconda"},{"location":"ce5362-swmodeling-lesson-1/#install-swmm","text":"I will do this live, so I have a current copy (also to see if it works on AWS as expected). The other special script block is below! # Script block to identify host, user, and kernel import sys ! hostname ! whoami print(sys.executable) print(sys.version) print(sys.version_info) # Script block to left align Markdown Tables atomickitty.aws antares /opt/jupyterhub/bin/python3 3.6.9 (default, Oct 8 2020, 12:12:24) [GCC 8.4.0] sys.version_info(major=3, minor=6, micro=9, releaselevel='final', serial=0)","title":"Install SWMM"},{"location":"placeholder/","text":"placeholder file","title":"Placeholder"},{"location":"syllabus/","text":"CE 5362 Surface Water Modeling Spring 2021 Catalog Description: Theory and application of hydrodynamic and mass transport models. Representative application of models for watershed and/or estuary modeling of flow and constituent transport. 3 credit hours comprising of lecture and hands-on workshop/exercise sessions. Course Overview The course trains engineers to practice hydrologic and hydraulic modeling in one-dimensional unsteady conditions; and in higher spatial dimensions (2D/3D) using custom-written and professional software tools. Integration of simulation tools to examine complex systems is emphasized. Prerequisites: COVID-19 Important Guidelines: If Texas Tech University campus operations are required to change because of health concerns related to the COVID-19 pandemic, it is possible that this course will move to a fully online delivery format. Should that be necessary, students will be advised of technical and/or equipment requirements, including remote proctoring software. Policy on absences resulting from illness: We anticipate that some students may have extended absences. To avoid students feeling compelled to attend in-person class periods when having symptoms or feeling unwell, a standard policy is provided that holds students harmless for illness-related absences (see Section A below). A. Illness-Based Absence Policy (Face-to-Face Classes) If at any time during the semester you are ill, in the interest of your own health and safety as well as the health and safety of your instructors and classmates, you are encouraged not to attend face-to-face class meetings or events. Please review the steps outlined below that you should follow to ensure your absence for illness will be excused. These steps also apply to not participating in synchronous online class meetings if you feel too ill to do so and missing specified assignment due dates in asynchronous online classes because of illness. If you are ill and think the symptoms might be COVID-19-related: Call Student Health Services at 806.743.2848 or your health care provider. During after-hours and on weekends, contact TTU COVID-19 Helpline at TBD. Self-report as soon as possible using the Dean of Students COVID-19 webpage. This website has specific directions about how to upload documentation from a medical provider and what will happen if your illness renders you unable to participate in classes for more than one week. If your illness is determined to be COVID-19-related, all remaining documentation and communication will be handled through the Office of the Dean of Students, including notification of your instructors of the time you may be absent from and may return to classes. If your illness is determined not to be COVID-19-related, please follow steps 2.a-d below. If you are ill and can attribute your symptoms to something other than COVID-19: If your illness renders you unable to attend face-to-face classes, participate in synchronous online classes, or miss specified assignment due dates in asynchronous online classes, you are encouraged to contact either Student Health Services at 806.743.2848 or your health care provider. Note that Student Health Services and your own and other health care providers may arrange virtual visits. During the health provider visit, request a \u201creturn to school\u201d note. E-mail the instructor a picture of that note. Return to class by the next class period after the date indicated on your note. Following the steps outlined above helps to keep your instructors informed about your absences and ensures your absence or missing an assignment due date because of illness will be marked excused. You will still be responsible to complete within a week of returning to class any assignments, quizzes, or exams you miss because of illness. B. Illness-Based Absence Policy (Telepresence Classes) Same as above with respect potential to infect others; go to a health care provider if you are ill. Telepresence courses are recorded and will be available on TTU MediaSite and/or YouTube (unlisted). Exercises, Quizzes, and Examinations are all administered by a Learning Management System (Blackboard) and users need to allow enough time to complete and upload their work> Course Sections Lesson time, days, and location: Section D01; CRN ?????; 0800PM-0920PM M, W ; Telepresence (Zoom) Section 010; CRN ?????; 0800PM-0920PM M, W ; Telepresence (Zoom) Please note the times are selected so that international students can attend at a reasonable time of day. 0800PM LBB == 0800AM BST (next day) thus 0800PM M LBB == 0800PM T BST 0800PM W LBB == 0800PM TH BST Course Instructor: Instructor: Theodore G. Cleveland, Ph.D., P.E., M. ASCE, F. EWRI Email: theodore.cleveland@ttu.edu (put ENGR 5362 in subject line for email related to this class) Office location: Telepresence (Zoom; GoToMeeting; etc.) Office hours: TBD Teaching assistants: Email : none Office location: none Office hours: none Textbook: none Course Contents: Modeling Philosophy Hydraulics: 1-D Dynamic Wave Routing: Lax-Diffusion (Homebrew using JupyterLab/iPython) SWMM 1-D Branched Systems: Simulate the confluence of two streams in steady conditions using SWMM Simulate the confluence of two streams in unsteady conditions using SWMM 2-D Floodplain Approximation Interconnected Channel and Pond Routing (ICPR): Conceptualization Storage elements Routing elements, Approximations using SWMM. Hydrology: Subcatchment Representation: Shape and Scale, Runoff Generation Integrated H&H Models: Subdivision scale (ICPR concept); County scale (Branched 1D) ; Constituient Transport (Water Quality); Tracers, Reactive Transport, Green Infrastructure (GI) for WQ Enhancement Infiltration approaches Storage-Delay approaches Filtration approaches Advanced Topics (Time Permitting): EFCD for 2D Hydrodynamics SToRM for 2D Hydrodynamics Lattice-Boltzman Approach for 2D/3D hydrodynamics Learning Outcomes: On completion of the course, students will be able to: 1. Articulate relevant theory for 1D dynamic wave routing. 2. Develop a Lax-Diffusion model for time-varying flow in an open channel and compare results with professional tools (SWMM). 3. Simulate the confluence of two streams in steady and unsteady conditions using professional tools (SWMM). 4. Articulate ICPR concept for approximating 2D estuary/floodplains 5. Employ the ICPR concept for approximating 2D estuary/floodplains 6. Approximate constituient transport in surface water systems 7. Articulate green infrastructure approaches to water quality enhancement 8. Articulate awareness of alternative modeling approaches (Lattice-Boltzman Fluid Dynamics ...) ABET Student Outcomes Engineering: An ability to identify, formulate, and solve complex engineering problems by applying principles of engineering, science, and mathematics. An ability to acquire and apply new knowledge as needed, using appropriate learning strategies. The script block below is for table formatting no need to understand it. %%html <style> table {margin-left: 0 !important;} </style> table {margin-left: 0 !important;} --- Course Schedule Item Lesson Workshop/Exercises Tools 25 Jan 2021 1 Introduction: - Syllabus - Content Servers - LMS Server - Software Computing Environment set up: - Installing Anaconda (Win/MacOS/AWS) \u2013 Jupyter notebooks - Simple Examples 27Jan2021 2 Modeling Philosophy: - Why model - Parsimony 28 Jan 2021 Mass Conservation: - Computational Cell - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 1D Open Channel Hydraulics 1 Feb 2021 4 Mass Conservation: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 3 Feb 2021 5 Momentum Conservation: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 8 Feb 2021 6 Steady Flow Algorithms: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 10 Feb 2021 7 Steady Flow Codes : - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 15 Feb 2021 8 Steady Flow in SWMM: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 17 Feb 2021 9 Confluence (Wurbs and James): - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 22 Feb 2021 10 Unsteady Flow Algorithms: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 24 Feb 2021 11 Unsteady Flow Code (homebrew): - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 1 Mar 2021 12 Unsteady Flow Code (homebrew): - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 3 Mar 2021 13 Unsteady Flow in SWMM: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 8 Mar 2021 14 Confluence : (Wang et. al.): - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 10 Mar 2021 16 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 15 Mar 2021 17 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 17 Mar 2021 18 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 22 Mar 2021 19 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 24 Mar 2021 20 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 29 Mar 2021 21 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 placeholder 31 Mar 2021 22 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 5 Apr 2021 23 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 7 Apr 2021 24 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 12 Apr 2021 25 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 placeholder 14 Apr 2021 26 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 19 Apr 2021 27 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 21 Apr 2021 28 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 26 Apr 2021 29 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 28 Apr 2021 30 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 3 May 2021 31topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 10 May 2021 Final Project Report and Link to Video Assessment Instruments and Grading Criteria: There will be an exam and several quizzes and homeworks/project for the course. Grades will be based on the following components; weighting is approximate: Assessment Instrument Total points Weight(%) Exams/Quizzes 25 Literature Review 25 Homeworks/Project 50 Overall total 100 Letter grades will be assigned using the following proportions: Normalized Score Range Letter Grade \u2265 85 A 75-84 B 65-74 C 55-64 D < 55 F Resources/Tools Amazon Web Services Lightsail (Virtual Private Server) Instances: Low cost (~24 USD/month or less) compute servers for running models on a remote AWS maintained machine. This is what the instructor will use for Jupyter notebooks, and the various professional tools. Additional Platforms for Python Anaconda platform (https://www.anaconda.com/): Anaconda distribution is an open-source Data Science Distribution Development Platform. It includes Python 3 with over 1,500 data science packages making it easy to manage libraries and dependencies. Available in Linux (x86-64 only), Windows, and Mac OS X. Jupyter (https://jupyter.org/): JupyterLab is a web-based interactive development environment for Jupyter notebooks, code, and data. JupyterLab is flexible: Configure and arrange the user interface to support a wide range of workflows in data science, scientific computing, and machine learning. note Anaconda for MacOS includes a JupyterLab instance, so a separate install is not required. Additional Modules Math module (https://docs.python.org/3/library/math.html): Gives access to the mathematical functions defined by the C standard e.g. factorial, gcd, exponential, logarithm. Operator module (https://docs.python.org/3/library/operator.html): Helps in exporting a set of efficient functions corresponding to the intrinsic operators of Python. For example, the operator add(x,y) is equivalent to the expression x+y. Scipy module (https://www.scipy.org/): A Python-based ecosystem of open-source software for mathematics, science, and engineering. Some of the core packages are: Numpy: Provides n-dimensional array package Scipy: Fundamental for scientific computing (e.g. linear algorithm, optimization) Matplotlib: Visualizations/2D plotting IPython: Enhanced interactive console <<= this is the kernel used in JupyterLab Pandas: Data structures and data analysis Scikit-learn module (https://scikit-learn.org/stable/): A library for machine learning in Python. It is a simple and efficient tool for predictive data analysis. It is built on NumPy, SciPy, and matplotlib modules. JupyterLab hardware requirements are minimal, in fact this syllabus was initially created using a JupyterLab notebook (as a markdown processor) on a RaspberryPi. Classroom Policy: The following activities are not allowed in the classroom: Texting or talking on the cellphone or other electronic devices, and reading non-course related materials. Telepresence (On-line) Courses Obviously electronic devices are vital; disrupting the webinar is prohibited, please mute your microphone unless you have a question - consider typing your question into the chat window as well. ADA Statement: Any student who, because of a disability, may require special arrangements in order to meet the course requirements should contact the instructor as soon as possible to make necessary arrangements. Students must present appropriate verification from Student Disability Services during the instructor's office hours. Please note that instructors are not allowed to provide classroom accommodation to a student until appropriate verification from Student Disability Services has been provided. For additional information, please contact Student Disability Services office in 335 West Hall or call 806.742.2405. Academic Integrity Statement: Academic integrity is taking responsibility for one\u2019s own class and/or course work, being individually accountable, and demonstrating intellectual honesty and ethical behavior. Academic integrity is a personal choice to abide by the standards of intellectual honesty and responsibility. Because education is a shared effort to achieve learning through the exchange of ideas, students, faculty, and staff have the collective responsibility to build mutual trust and respect. Ethical behavior and independent thought are essential for the highest level of academic achievement, which then must be measured. Academic achievement includes scholarship, teaching, and learning, all of which are shared endeavors. Grades are a device used to quantify the successful accumulation of knowledge through learning. Adhering to the standards of academic integrity ensures grades are earned honestly. Academic integrity is the foundation upon which students, faculty, and staff build their educational and professional careers. [Texas Tech University (\u201cUniversity\u201d) Quality Enhancement Plan, Academic Integrity Task Force, 2010]. Religious Holy Day Statement: \u201cReligious holy day\u201d means a holy day observed by a religion whose places of worship are exempt from property taxation under Texas Tax Code \u00a711.20. A student who intends to observe a religious holy day should make that intention known to the instructor prior to the absence. A student who is absent from classes for the observance of a religious holy day shall be allowed to take an examination or complete an assignment scheduled for that day within a reasonable time after the absence. A student who is excused may not be penalized for the absence; however, the instructor may respond appropriately if the student fails to complete the assignment satisfactorily. Ethical Conduct Policy: Cheating is prohibited, and the representation of the work of another person as your own will be grounds for receiving a failing grade in the course. --- The script block below identifies server last used to render notebook # Script block to identify host, user, and kernel import sys ! hostname ! whoami print(sys.executable) print(sys.version) print(sys.version_info) # Script block to left align Markdown Tables atomickitty.aws antares /opt/jupyterhub/bin/python3 3.6.9 (default, Oct 8 2020, 12:12:24) [GCC 8.4.0] sys.version_info(major=3, minor=6, micro=9, releaselevel='final', serial=0)","title":"Syllabus"},{"location":"syllabus/#ce-5362-surface-water-modeling","text":"Spring 2021","title":"CE 5362 Surface Water Modeling"},{"location":"syllabus/#catalog-description","text":"Theory and application of hydrodynamic and mass transport models. Representative application of models for watershed and/or estuary modeling of flow and constituent transport. 3 credit hours comprising of lecture and hands-on workshop/exercise sessions.","title":"Catalog Description:"},{"location":"syllabus/#course-overview","text":"The course trains engineers to practice hydrologic and hydraulic modeling in one-dimensional unsteady conditions; and in higher spatial dimensions (2D/3D) using custom-written and professional software tools. Integration of simulation tools to examine complex systems is emphasized.","title":"Course Overview"},{"location":"syllabus/#prerequisites","text":"","title":"Prerequisites:"},{"location":"syllabus/#covid-19-important-guidelines","text":"If Texas Tech University campus operations are required to change because of health concerns related to the COVID-19 pandemic, it is possible that this course will move to a fully online delivery format. Should that be necessary, students will be advised of technical and/or equipment requirements, including remote proctoring software. Policy on absences resulting from illness: We anticipate that some students may have extended absences. To avoid students feeling compelled to attend in-person class periods when having symptoms or feeling unwell, a standard policy is provided that holds students harmless for illness-related absences (see Section A below).","title":"COVID-19 Important Guidelines:"},{"location":"syllabus/#a-illness-based-absence-policy-face-to-face-classes","text":"If at any time during the semester you are ill, in the interest of your own health and safety as well as the health and safety of your instructors and classmates, you are encouraged not to attend face-to-face class meetings or events. Please review the steps outlined below that you should follow to ensure your absence for illness will be excused. These steps also apply to not participating in synchronous online class meetings if you feel too ill to do so and missing specified assignment due dates in asynchronous online classes because of illness. If you are ill and think the symptoms might be COVID-19-related: Call Student Health Services at 806.743.2848 or your health care provider. During after-hours and on weekends, contact TTU COVID-19 Helpline at TBD. Self-report as soon as possible using the Dean of Students COVID-19 webpage. This website has specific directions about how to upload documentation from a medical provider and what will happen if your illness renders you unable to participate in classes for more than one week. If your illness is determined to be COVID-19-related, all remaining documentation and communication will be handled through the Office of the Dean of Students, including notification of your instructors of the time you may be absent from and may return to classes. If your illness is determined not to be COVID-19-related, please follow steps 2.a-d below. If you are ill and can attribute your symptoms to something other than COVID-19: If your illness renders you unable to attend face-to-face classes, participate in synchronous online classes, or miss specified assignment due dates in asynchronous online classes, you are encouraged to contact either Student Health Services at 806.743.2848 or your health care provider. Note that Student Health Services and your own and other health care providers may arrange virtual visits. During the health provider visit, request a \u201creturn to school\u201d note. E-mail the instructor a picture of that note. Return to class by the next class period after the date indicated on your note. Following the steps outlined above helps to keep your instructors informed about your absences and ensures your absence or missing an assignment due date because of illness will be marked excused. You will still be responsible to complete within a week of returning to class any assignments, quizzes, or exams you miss because of illness.","title":"A. Illness-Based Absence Policy (Face-to-Face Classes)"},{"location":"syllabus/#b-illness-based-absence-policy-telepresence-classes","text":"Same as above with respect potential to infect others; go to a health care provider if you are ill. Telepresence courses are recorded and will be available on TTU MediaSite and/or YouTube (unlisted). Exercises, Quizzes, and Examinations are all administered by a Learning Management System (Blackboard) and users need to allow enough time to complete and upload their work>","title":"B. Illness-Based Absence Policy (Telepresence Classes)"},{"location":"syllabus/#course-sections","text":"Lesson time, days, and location: Section D01; CRN ?????; 0800PM-0920PM M, W ; Telepresence (Zoom) Section 010; CRN ?????; 0800PM-0920PM M, W ; Telepresence (Zoom) Please note the times are selected so that international students can attend at a reasonable time of day. 0800PM LBB == 0800AM BST (next day) thus 0800PM M LBB == 0800PM T BST 0800PM W LBB == 0800PM TH BST","title":"Course Sections"},{"location":"syllabus/#course-instructor","text":"Instructor: Theodore G. Cleveland, Ph.D., P.E., M. ASCE, F. EWRI Email: theodore.cleveland@ttu.edu (put ENGR 5362 in subject line for email related to this class) Office location: Telepresence (Zoom; GoToMeeting; etc.) Office hours: TBD","title":"Course Instructor:"},{"location":"syllabus/#teaching-assistants","text":"Email : none Office location: none Office hours: none","title":"Teaching assistants:"},{"location":"syllabus/#textbook","text":"none","title":"Textbook:"},{"location":"syllabus/#course-contents","text":"Modeling Philosophy Hydraulics: 1-D Dynamic Wave Routing: Lax-Diffusion (Homebrew using JupyterLab/iPython) SWMM 1-D Branched Systems: Simulate the confluence of two streams in steady conditions using SWMM Simulate the confluence of two streams in unsteady conditions using SWMM 2-D Floodplain Approximation Interconnected Channel and Pond Routing (ICPR): Conceptualization Storage elements Routing elements, Approximations using SWMM. Hydrology: Subcatchment Representation: Shape and Scale, Runoff Generation Integrated H&H Models: Subdivision scale (ICPR concept); County scale (Branched 1D) ; Constituient Transport (Water Quality); Tracers, Reactive Transport, Green Infrastructure (GI) for WQ Enhancement Infiltration approaches Storage-Delay approaches Filtration approaches Advanced Topics (Time Permitting): EFCD for 2D Hydrodynamics SToRM for 2D Hydrodynamics Lattice-Boltzman Approach for 2D/3D hydrodynamics","title":"Course Contents:"},{"location":"syllabus/#learning-outcomes","text":"On completion of the course, students will be able to: 1. Articulate relevant theory for 1D dynamic wave routing. 2. Develop a Lax-Diffusion model for time-varying flow in an open channel and compare results with professional tools (SWMM). 3. Simulate the confluence of two streams in steady and unsteady conditions using professional tools (SWMM). 4. Articulate ICPR concept for approximating 2D estuary/floodplains 5. Employ the ICPR concept for approximating 2D estuary/floodplains 6. Approximate constituient transport in surface water systems 7. Articulate green infrastructure approaches to water quality enhancement 8. Articulate awareness of alternative modeling approaches (Lattice-Boltzman Fluid Dynamics ...)","title":"Learning Outcomes:"},{"location":"syllabus/#abet-student-outcomes","text":"Engineering: An ability to identify, formulate, and solve complex engineering problems by applying principles of engineering, science, and mathematics. An ability to acquire and apply new knowledge as needed, using appropriate learning strategies. The script block below is for table formatting no need to understand it. %%html <style> table {margin-left: 0 !important;} </style> table {margin-left: 0 !important;}","title":"ABET Student Outcomes"},{"location":"syllabus/#-","text":"","title":"---"},{"location":"syllabus/#course-schedule","text":"Item Lesson Workshop/Exercises Tools 25 Jan 2021 1 Introduction: - Syllabus - Content Servers - LMS Server - Software Computing Environment set up: - Installing Anaconda (Win/MacOS/AWS) \u2013 Jupyter notebooks - Simple Examples 27Jan2021 2 Modeling Philosophy: - Why model - Parsimony 28 Jan 2021 Mass Conservation: - Computational Cell - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 1D Open Channel Hydraulics 1 Feb 2021 4 Mass Conservation: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 3 Feb 2021 5 Momentum Conservation: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 8 Feb 2021 6 Steady Flow Algorithms: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 10 Feb 2021 7 Steady Flow Codes : - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 15 Feb 2021 8 Steady Flow in SWMM: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 17 Feb 2021 9 Confluence (Wurbs and James): - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 22 Feb 2021 10 Unsteady Flow Algorithms: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 24 Feb 2021 11 Unsteady Flow Code (homebrew): - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 1 Mar 2021 12 Unsteady Flow Code (homebrew): - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 3 Mar 2021 13 Unsteady Flow in SWMM: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 8 Mar 2021 14 Confluence : (Wang et. al.): - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 10 Mar 2021 16 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 15 Mar 2021 17 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 17 Mar 2021 18 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 22 Mar 2021 19 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 24 Mar 2021 20 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 29 Mar 2021 21 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 placeholder 31 Mar 2021 22 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 5 Apr 2021 23 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 7 Apr 2021 24 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 12 Apr 2021 25 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 placeholder 14 Apr 2021 26 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 19 Apr 2021 27 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 21 Apr 2021 28 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 26 Apr 2021 29 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 28 Apr 2021 30 topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 3 May 2021 31topic ...: - subtopic1 - subtopic2 - subtopic3 laboratory - subtopic1 - subtopic2 - subtopic3 10 May 2021 Final Project Report and Link to Video","title":"Course Schedule"},{"location":"syllabus/#assessment-instruments-and-grading-criteria","text":"There will be an exam and several quizzes and homeworks/project for the course. Grades will be based on the following components; weighting is approximate: Assessment Instrument Total points Weight(%) Exams/Quizzes 25 Literature Review 25 Homeworks/Project 50 Overall total 100 Letter grades will be assigned using the following proportions: Normalized Score Range Letter Grade \u2265 85 A 75-84 B 65-74 C 55-64 D < 55 F","title":"Assessment Instruments and Grading Criteria:"},{"location":"syllabus/#resourcestools","text":"","title":"Resources/Tools"},{"location":"syllabus/#amazon-web-services","text":"Lightsail (Virtual Private Server) Instances: Low cost (~24 USD/month or less) compute servers for running models on a remote AWS maintained machine. This is what the instructor will use for Jupyter notebooks, and the various professional tools.","title":"Amazon Web Services"},{"location":"syllabus/#additional-platforms-for-python","text":"Anaconda platform (https://www.anaconda.com/): Anaconda distribution is an open-source Data Science Distribution Development Platform. It includes Python 3 with over 1,500 data science packages making it easy to manage libraries and dependencies. Available in Linux (x86-64 only), Windows, and Mac OS X. Jupyter (https://jupyter.org/): JupyterLab is a web-based interactive development environment for Jupyter notebooks, code, and data. JupyterLab is flexible: Configure and arrange the user interface to support a wide range of workflows in data science, scientific computing, and machine learning. note Anaconda for MacOS includes a JupyterLab instance, so a separate install is not required.","title":"Additional Platforms for Python"},{"location":"syllabus/#additional-modules","text":"Math module (https://docs.python.org/3/library/math.html): Gives access to the mathematical functions defined by the C standard e.g. factorial, gcd, exponential, logarithm. Operator module (https://docs.python.org/3/library/operator.html): Helps in exporting a set of efficient functions corresponding to the intrinsic operators of Python. For example, the operator add(x,y) is equivalent to the expression x+y. Scipy module (https://www.scipy.org/): A Python-based ecosystem of open-source software for mathematics, science, and engineering. Some of the core packages are: Numpy: Provides n-dimensional array package Scipy: Fundamental for scientific computing (e.g. linear algorithm, optimization) Matplotlib: Visualizations/2D plotting IPython: Enhanced interactive console <<= this is the kernel used in JupyterLab Pandas: Data structures and data analysis Scikit-learn module (https://scikit-learn.org/stable/): A library for machine learning in Python. It is a simple and efficient tool for predictive data analysis. It is built on NumPy, SciPy, and matplotlib modules. JupyterLab hardware requirements are minimal, in fact this syllabus was initially created using a JupyterLab notebook (as a markdown processor) on a RaspberryPi.","title":"Additional Modules"},{"location":"syllabus/#classroom-policy","text":"The following activities are not allowed in the classroom: Texting or talking on the cellphone or other electronic devices, and reading non-course related materials.","title":"Classroom Policy:"},{"location":"syllabus/#telepresence-on-line-courses","text":"Obviously electronic devices are vital; disrupting the webinar is prohibited, please mute your microphone unless you have a question - consider typing your question into the chat window as well.","title":"Telepresence (On-line) Courses"},{"location":"syllabus/#ada-statement","text":"Any student who, because of a disability, may require special arrangements in order to meet the course requirements should contact the instructor as soon as possible to make necessary arrangements. Students must present appropriate verification from Student Disability Services during the instructor's office hours. Please note that instructors are not allowed to provide classroom accommodation to a student until appropriate verification from Student Disability Services has been provided. For additional information, please contact Student Disability Services office in 335 West Hall or call 806.742.2405.","title":"ADA Statement:"},{"location":"syllabus/#academic-integrity-statement","text":"Academic integrity is taking responsibility for one\u2019s own class and/or course work, being individually accountable, and demonstrating intellectual honesty and ethical behavior. Academic integrity is a personal choice to abide by the standards of intellectual honesty and responsibility. Because education is a shared effort to achieve learning through the exchange of ideas, students, faculty, and staff have the collective responsibility to build mutual trust and respect. Ethical behavior and independent thought are essential for the highest level of academic achievement, which then must be measured. Academic achievement includes scholarship, teaching, and learning, all of which are shared endeavors. Grades are a device used to quantify the successful accumulation of knowledge through learning. Adhering to the standards of academic integrity ensures grades are earned honestly. Academic integrity is the foundation upon which students, faculty, and staff build their educational and professional careers. [Texas Tech University (\u201cUniversity\u201d) Quality Enhancement Plan, Academic Integrity Task Force, 2010].","title":"Academic Integrity Statement:"},{"location":"syllabus/#religious-holy-day-statement","text":"\u201cReligious holy day\u201d means a holy day observed by a religion whose places of worship are exempt from property taxation under Texas Tax Code \u00a711.20. A student who intends to observe a religious holy day should make that intention known to the instructor prior to the absence. A student who is absent from classes for the observance of a religious holy day shall be allowed to take an examination or complete an assignment scheduled for that day within a reasonable time after the absence. A student who is excused may not be penalized for the absence; however, the instructor may respond appropriately if the student fails to complete the assignment satisfactorily.","title":"Religious Holy Day Statement:"},{"location":"syllabus/#ethical-conduct-policy","text":"Cheating is prohibited, and the representation of the work of another person as your own will be grounds for receiving a failing grade in the course.","title":"Ethical Conduct Policy:"},{"location":"syllabus/#-_1","text":"The script block below identifies server last used to render notebook # Script block to identify host, user, and kernel import sys ! hostname ! whoami print(sys.executable) print(sys.version) print(sys.version_info) # Script block to left align Markdown Tables atomickitty.aws antares /opt/jupyterhub/bin/python3 3.6.9 (default, Oct 8 2020, 12:12:24) [GCC 8.4.0] sys.version_info(major=3, minor=6, micro=9, releaselevel='final', serial=0)","title":"---"},{"location":"untitled/","text":"another placeholder","title":"Exam 3 Solution"},{"location":"workshop1/","text":"Workshop 1 -- Title A short description, such as installing HEC-HMS Onto your local computer (Windows) Onto a cloud provider (AWS Lightsail) Workshop Objectives ABET Criteria Actual tutorial","title":"Workshop 1 -- Title"},{"location":"workshop1/#workshop-1-title","text":"A short description, such as installing HEC-HMS Onto your local computer (Windows) Onto a cloud provider (AWS Lightsail)","title":"Workshop 1 -- Title"},{"location":"workshop1/#workshop-objectives","text":"","title":"Workshop Objectives"},{"location":"workshop1/#abet-criteria","text":"","title":"ABET Criteria"},{"location":"workshop1/#actual-tutorial","text":"","title":"Actual tutorial"},{"location":"lesson2/ce5362-swmodeling-lesson-2.1/","text":"CE 5362 Lesson 2 Part 1 Modeling Philosophy Modeling What is a model? Why model? Parsimony Modeling Protocol Algorithms and Programming Modeling Computational hydraulics aims to provide the engineer with guidance for correct design, construction, and operation of hydraulic works, including closed conduit, open conduit, and porous flow systems. The computational procedures are reasonably complex and typically beyond the limits of hand computation; computer programs are necessary and required for many computational hydraulics problems. Modeling is the art of representing reality in a simplified form, sufficient to answer questions about that reality What is a Model? There are many definitions, a few are: A model is a simplification of reality that duplicates the excitation-response of the real system but is faster, smaller, or more practical to study than the real system. A mathematical model is composed of mathematical expressions quantifying fundamental physical principles (force, energy, mass, etc.). These expressions are adapted and simplified in each case to the special features of the problem to be tackled. A model is any device that represents an approximation of a field situation. There are several categories of models: Physical models such as laboratory sand tanks, flumes, pipe networks, porous columns, batch reactors, and pilot plants are used to directly simulate various conditions anticipated in full scale settings. Physical models tend to be the most costly to build from scratch, but many questions cannot be answered without these kind of model Analog models such as electric circuit analogs or Hele-Shaw analogs are used to indirectly simulate field conditions by direct simulation in a domain analogous to the real setting. Analog computers are quite rare today, but in the 1960's were a principal tool in modeling and were used in aerospace as well as mundane civil engineering applications. A laboratory mouse used to test medicine doses (usually for lethality) is an example of an analog model for human testing. Bear (1972), Chapter 11 provides an excellent background on analog models. The treatment is mostly aimed at porous medium flow, but the concepts are generic. The book has some nice photographs of electric-analog computers (which are rare today). Mathematical models indirectly simulate field conditions by solution of a governing equation thought to represent the system, along with auxiliary equations that describe the boundary and forcing conditions. These physics and chemical relationships are represented as sets of algebraic equations. Conversion from physics to the computer is via finite-difference, finite-element, finite-volume analysis. Particle tracking is an alternate approach. Mathematical models are solved analytically or numerically -- both solutions may require a computer. The set of commands used to solve a mathematical problem on a computer is the program or code. The code is generic, whereas a model is comprised of boundary and initial conditions, a computational grid, material properties on that grid, and forcing terms. Thus a model is both the data and code, whereas the code alone is just a tool waiting for use. Another kind of model is a statistical (or data model) model that relates observations to excitations without necessarily attempting to relate underlying physics of the problem (Machine Learning; Neural Networks, Regression Trees, Support Vector Machines are these kind of models). All the kinds of models are useful and appropriate tools in their various applications. Why Model? There are several good reasons to model, and many poor reasons. - Most modeling efforts are attempts to predict the consequences of a proposed design or operation strategy. - Models can also be used to interpret system dynamics or as a framework for organizing data. - Models can also be used to study processes in generic settings. Generic models are useful in formulating regulatory guidelines and as screening tools to identify suitable or unsuitable designs. These three modeling applications are fundamentally different -- even though they use the same toolkits. Table 1 lists these three application types along with some opinions as to the need to calibrate. Table 1. Types of Model Applications Model Type Uses Remarks Predictive Used to predict responses to changes. What if ...? Requires Calibration Interpretive Used as a framework for studying system dynamics; framework for organzing data Calibraton Optional Generic Analyze behavior in hypothetical systems; useful for framing regulatory/control guidelines Calibraton Optional Models should be investigated and used only if they can answer questions that need to be answered. - A list of questions should be prepared prior to beginning a modeling exercise, there are likely some situations where a model may not even be needed. - Models should not be expected to \u201cprove\" anything -- a computer model cannot prove anything. - Models are useful to identify poor solutions to a problem, but rarely can they identify best solutions. - Models can be used to evaluate alternative designs (and this task is a good use of a model). - Models can occasionally be used to detect natural relationships that would otherwise go unnoticed. Principle of Parsimony The principle of parsimony is fundamental in engineering modeling. A model should only be as complex as necessary to answer the questions asked of it. All other things being equal a simpler model (fewer parameters) is preferred to a complicated model. This principle is sometimes referred to as Occam's razor. A Modeling Protocol A straightforward modeling protocol can be modeled on the classic \"Scientific Method\" List the questions that need to be answered -- this step is crucial, it is the problem statement. List the available and necessary data to answer the questions. If the data do not exist, that fact should also be noted. Assuming a model is the best tool, list the physical principles that need to be preserved in a model. Develop and test an algorithm to simulate the physical principles. In many cases, a professional program will be the tool of choice, although sometimes a \u201croll-your-own\u201d approach makes better sense. Prior to actually solving the problem in question, develop and test simple problems to which you know the answer. This exercise develops the modelers skill and builds confidence in the tool. Apply the model working from a simple, known solution towards the problem to which you seek the actual solution. This step requires keeping a \u201csimulation log.\" In this log, file names should be recorded (input files should change name each new run -- record in the log the general nature of each simulation, the output, and the modelers interpretation for each new run) When the real problem is run construct professional exhibits (graphs, tables, etc.) for inclusion in the modeling report. Pages of output may be meaningful, but are not sufficient for a professional document. Build the modeling report, including the methods used, inputs and assumptions, outputs (results) and their interpretation in the context of the original problem. Anderson and Woessner (1992), pages 2 - 10, is an excellent discussion of modeling philosophy and protocol. Their book is also aimed at porous flow modeling, but again the concepts are generic. The reader will find these notes borrow (nearly verbatim!) from this reference source. Algorithm An algorithmic procedure can be represented as x = f(a) From a mathematical perspective the main concern is that the algorithm is well posed: A solution exists for a given a . The computation must lead to a single solution for x given a . The results for x must be connected to the input a through the Lipschitz relation: |\\delta a| < \\eta ~\\texttt{then}~ |\\delta x| < M|\\delta a| where M is a bounded natural number, M = M(a;\\eta) . Many problems are not well posed as stated, but with some reasonable assumptions can be forced into such a state. Thus an algorithm is a recipe to take input data and produce output responses through some relationships. If a well posed problem then each result is related to the inputs, and the same inputs (in an algorithm) produce the same results. By the recipe analogy, if you follow the same recipe each time with the same raw materials then the cake should taste the same when it is baked. An important concept from above is that an algorithm operates on data (a procedure-oriented approach); whereas an object-oriented view is that an algorithm performs a task (generate response) based on states established by the data. Both points of view are valid and equivalent. Most computational hydraulics models were built (by a quirk of history) in a procedure- oriented perspective. More recent tools are somewhat of a hybrid creation. Tools A practicing modeler needs a toolkit - these tools range from the actual computation engines (EPA-SWMM, HEC-RAS, FESWMS, HSPF, WSPRO, TR-20, etc.) to analysis tools for result interpretation (Python, R, Excel, etc.) to actual programming tools (Python, R, C, FORTRAN, PERL, etc.) to construct their own special purpose models or to test results from general purpose profes- sional models. In this course, Python will be used (interchangeably where practical) for programming and analysis. Professional codes (i.e. EPA-SWMM, EFDC, HEC-RAS, etc. will be used later in the course for semi-professional applications. Programming Why bother with any programming? There are three fundamental reasons for a programming experience in this (or any such) class: 1. Teaching someone else a subject or procedure forces the teacher to have a reasonable understanding of the subject or procedure. Teaching a computer (by virtue of programming) forces a very deep understanding of the underlying algorithm. 2. You will encounter situations that general purpose programs are not designed to address; if you have even only a moderate ability to build your own tools when you need to, then you can. In all likliehood, you will \"trick\" the professional program, but you cannot invent tricks unless you know a little bit about programming. 3. Programming a computer requires an algorithmic thought process - this process is valuable in many other areas of engineering, hence the act of programming is good discipline for other problems you will encounter. Why Python? Admittedly not my first choice, but in keeping with the WCOE emerging emphasis on Computational Thinking and the college's choice to standardize on Python 3.X (as implemented in Jupyter notebooks) that's the tool for this class. Because the goal in most cases is to answer a question using the tools, other choices are fine (R, C, C++, FORTRAN90, etc.), but I won't try very hard to help you debug your scripts if they are in R, C or FORTRAN. References Anderson, M. P. and W. W. Woessner (1992). Applied Groundwater Modeling. San Diego: Academic Press. (pp 2-10) Bear, J. (1972). Dynamics of Fluids in Porous Media. New York: Dover Publications, Inc. (Chapter 11)","title":"Part 1 Modeling"},{"location":"lesson2/ce5362-swmodeling-lesson-2.1/#ce-5362-lesson-2-part-1-modeling-philosophy","text":"Modeling What is a model? Why model? Parsimony Modeling Protocol Algorithms and Programming","title":"CE 5362 Lesson 2 Part 1 Modeling Philosophy"},{"location":"lesson2/ce5362-swmodeling-lesson-2.1/#modeling","text":"Computational hydraulics aims to provide the engineer with guidance for correct design, construction, and operation of hydraulic works, including closed conduit, open conduit, and porous flow systems. The computational procedures are reasonably complex and typically beyond the limits of hand computation; computer programs are necessary and required for many computational hydraulics problems. Modeling is the art of representing reality in a simplified form, sufficient to answer questions about that reality","title":"Modeling"},{"location":"lesson2/ce5362-swmodeling-lesson-2.1/#what-is-a-model","text":"There are many definitions, a few are: A model is a simplification of reality that duplicates the excitation-response of the real system but is faster, smaller, or more practical to study than the real system. A mathematical model is composed of mathematical expressions quantifying fundamental physical principles (force, energy, mass, etc.). These expressions are adapted and simplified in each case to the special features of the problem to be tackled. A model is any device that represents an approximation of a field situation. There are several categories of models: Physical models such as laboratory sand tanks, flumes, pipe networks, porous columns, batch reactors, and pilot plants are used to directly simulate various conditions anticipated in full scale settings. Physical models tend to be the most costly to build from scratch, but many questions cannot be answered without these kind of model Analog models such as electric circuit analogs or Hele-Shaw analogs are used to indirectly simulate field conditions by direct simulation in a domain analogous to the real setting. Analog computers are quite rare today, but in the 1960's were a principal tool in modeling and were used in aerospace as well as mundane civil engineering applications. A laboratory mouse used to test medicine doses (usually for lethality) is an example of an analog model for human testing. Bear (1972), Chapter 11 provides an excellent background on analog models. The treatment is mostly aimed at porous medium flow, but the concepts are generic. The book has some nice photographs of electric-analog computers (which are rare today). Mathematical models indirectly simulate field conditions by solution of a governing equation thought to represent the system, along with auxiliary equations that describe the boundary and forcing conditions. These physics and chemical relationships are represented as sets of algebraic equations. Conversion from physics to the computer is via finite-difference, finite-element, finite-volume analysis. Particle tracking is an alternate approach. Mathematical models are solved analytically or numerically -- both solutions may require a computer. The set of commands used to solve a mathematical problem on a computer is the program or code. The code is generic, whereas a model is comprised of boundary and initial conditions, a computational grid, material properties on that grid, and forcing terms. Thus a model is both the data and code, whereas the code alone is just a tool waiting for use. Another kind of model is a statistical (or data model) model that relates observations to excitations without necessarily attempting to relate underlying physics of the problem (Machine Learning; Neural Networks, Regression Trees, Support Vector Machines are these kind of models). All the kinds of models are useful and appropriate tools in their various applications.","title":"What is a Model?"},{"location":"lesson2/ce5362-swmodeling-lesson-2.1/#why-model","text":"There are several good reasons to model, and many poor reasons. - Most modeling efforts are attempts to predict the consequences of a proposed design or operation strategy. - Models can also be used to interpret system dynamics or as a framework for organizing data. - Models can also be used to study processes in generic settings. Generic models are useful in formulating regulatory guidelines and as screening tools to identify suitable or unsuitable designs. These three modeling applications are fundamentally different -- even though they use the same toolkits. Table 1 lists these three application types along with some opinions as to the need to calibrate. Table 1. Types of Model Applications Model Type Uses Remarks Predictive Used to predict responses to changes. What if ...? Requires Calibration Interpretive Used as a framework for studying system dynamics; framework for organzing data Calibraton Optional Generic Analyze behavior in hypothetical systems; useful for framing regulatory/control guidelines Calibraton Optional Models should be investigated and used only if they can answer questions that need to be answered. - A list of questions should be prepared prior to beginning a modeling exercise, there are likely some situations where a model may not even be needed. - Models should not be expected to \u201cprove\" anything -- a computer model cannot prove anything. - Models are useful to identify poor solutions to a problem, but rarely can they identify best solutions. - Models can be used to evaluate alternative designs (and this task is a good use of a model). - Models can occasionally be used to detect natural relationships that would otherwise go unnoticed.","title":"Why Model?"},{"location":"lesson2/ce5362-swmodeling-lesson-2.1/#principle-of-parsimony","text":"The principle of parsimony is fundamental in engineering modeling. A model should only be as complex as necessary to answer the questions asked of it. All other things being equal a simpler model (fewer parameters) is preferred to a complicated model. This principle is sometimes referred to as Occam's razor.","title":"Principle of Parsimony"},{"location":"lesson2/ce5362-swmodeling-lesson-2.1/#a-modeling-protocol","text":"A straightforward modeling protocol can be modeled on the classic \"Scientific Method\" List the questions that need to be answered -- this step is crucial, it is the problem statement. List the available and necessary data to answer the questions. If the data do not exist, that fact should also be noted. Assuming a model is the best tool, list the physical principles that need to be preserved in a model. Develop and test an algorithm to simulate the physical principles. In many cases, a professional program will be the tool of choice, although sometimes a \u201croll-your-own\u201d approach makes better sense. Prior to actually solving the problem in question, develop and test simple problems to which you know the answer. This exercise develops the modelers skill and builds confidence in the tool. Apply the model working from a simple, known solution towards the problem to which you seek the actual solution. This step requires keeping a \u201csimulation log.\" In this log, file names should be recorded (input files should change name each new run -- record in the log the general nature of each simulation, the output, and the modelers interpretation for each new run) When the real problem is run construct professional exhibits (graphs, tables, etc.) for inclusion in the modeling report. Pages of output may be meaningful, but are not sufficient for a professional document. Build the modeling report, including the methods used, inputs and assumptions, outputs (results) and their interpretation in the context of the original problem. Anderson and Woessner (1992), pages 2 - 10, is an excellent discussion of modeling philosophy and protocol. Their book is also aimed at porous flow modeling, but again the concepts are generic. The reader will find these notes borrow (nearly verbatim!) from this reference source.","title":"A Modeling Protocol"},{"location":"lesson2/ce5362-swmodeling-lesson-2.1/#algorithm","text":"An algorithmic procedure can be represented as x = f(a) From a mathematical perspective the main concern is that the algorithm is well posed: A solution exists for a given a . The computation must lead to a single solution for x given a . The results for x must be connected to the input a through the Lipschitz relation: |\\delta a| < \\eta ~\\texttt{then}~ |\\delta x| < M|\\delta a| where M is a bounded natural number, M = M(a;\\eta) . Many problems are not well posed as stated, but with some reasonable assumptions can be forced into such a state. Thus an algorithm is a recipe to take input data and produce output responses through some relationships. If a well posed problem then each result is related to the inputs, and the same inputs (in an algorithm) produce the same results. By the recipe analogy, if you follow the same recipe each time with the same raw materials then the cake should taste the same when it is baked. An important concept from above is that an algorithm operates on data (a procedure-oriented approach); whereas an object-oriented view is that an algorithm performs a task (generate response) based on states established by the data. Both points of view are valid and equivalent. Most computational hydraulics models were built (by a quirk of history) in a procedure- oriented perspective. More recent tools are somewhat of a hybrid creation.","title":"Algorithm"},{"location":"lesson2/ce5362-swmodeling-lesson-2.1/#tools","text":"A practicing modeler needs a toolkit - these tools range from the actual computation engines (EPA-SWMM, HEC-RAS, FESWMS, HSPF, WSPRO, TR-20, etc.) to analysis tools for result interpretation (Python, R, Excel, etc.) to actual programming tools (Python, R, C, FORTRAN, PERL, etc.) to construct their own special purpose models or to test results from general purpose profes- sional models. In this course, Python will be used (interchangeably where practical) for programming and analysis. Professional codes (i.e. EPA-SWMM, EFDC, HEC-RAS, etc. will be used later in the course for semi-professional applications.","title":"Tools"},{"location":"lesson2/ce5362-swmodeling-lesson-2.1/#programming","text":"Why bother with any programming? There are three fundamental reasons for a programming experience in this (or any such) class: 1. Teaching someone else a subject or procedure forces the teacher to have a reasonable understanding of the subject or procedure. Teaching a computer (by virtue of programming) forces a very deep understanding of the underlying algorithm. 2. You will encounter situations that general purpose programs are not designed to address; if you have even only a moderate ability to build your own tools when you need to, then you can. In all likliehood, you will \"trick\" the professional program, but you cannot invent tricks unless you know a little bit about programming. 3. Programming a computer requires an algorithmic thought process - this process is valuable in many other areas of engineering, hence the act of programming is good discipline for other problems you will encounter. Why Python? Admittedly not my first choice, but in keeping with the WCOE emerging emphasis on Computational Thinking and the college's choice to standardize on Python 3.X (as implemented in Jupyter notebooks) that's the tool for this class. Because the goal in most cases is to answer a question using the tools, other choices are fine (R, C, C++, FORTRAN90, etc.), but I won't try very hard to help you debug your scripts if they are in R, C or FORTRAN.","title":"Programming"},{"location":"lesson2/ce5362-swmodeling-lesson-2.1/#references","text":"Anderson, M. P. and W. W. Woessner (1992). Applied Groundwater Modeling. San Diego: Academic Press. (pp 2-10) Bear, J. (1972). Dynamics of Fluids in Porous Media. New York: Dover Publications, Inc. (Chapter 11)","title":"References"},{"location":"lesson2/ce5362-swmodeling-lesson-2.2/","text":"CE 5362 Lesson 2 Hydraulics Review Open Channel Hydraulics (A Review) 1D Spatial: St. Venant Equations Gradually Varied Flow Water Surface Profiles by Variable Step Water Surface Profiles by Fixed Step St. Venant Equations In general, 1-D unsteady flow would be considered state-of-practice computation; every engineer would be expected to be able to make such calculations (using professional software). 2-D computation is becoming routine using general purpose software. 3-D computation as of this writing (circa 2009) is still in the realm of state-of-art, and may not be within the capability a typical consulting firm. The conservation of mass, momentum, and energy in the context of the cell balance method is used herein to develop the mathematical and computational structure. The cell balance is a computational structure that is somewhat analogous to the Reynolds transport theorem, except the end results are difference equations that can be updates to approximate physical processes. The philosophy is a hybrid approach - instead of developing the differential equations first, then numerical approximations, the numerical constructs are built directly and the limiting process is employed to demonstrate that the constructs indeed mimic the differential equations that describe our current understanding of the physics. The Computational Cell The cell balance method envisions the world as representable by a computational cell (or more typically a collection of cells) with some finite dimension, fixed in space about a cell centroid. Some dimensions are changeable - such as depth. The fundamental computational element is a computational cell or a reach. Some professional software, in particular HEC-RAS, considers a reach to be a specific portion of a river system that may be comprised of several computational sub-reaches (cells). The engineer will need to consider the context and the tool used to decide which way to describe their problem to the program (and to the client). Figure 1 is a sketch of a portion of a channel. The left-most section is uphill (and upstream) of the right-most section. The section geometry is arbitrary, but is drawn to look like a channel cross section. Figure 1 Reach/Computational Cell The length of the reach (distance between each section along the flow path) is \\Delta x . The depth of liquid in the section is z , the width at the free surface is B(z) , the functional relationship established by the channel geometry. The flow into the reach on the upstream face is Q -\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2} The flow out of the reach on the downstream face Q +\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2} . The direction is strictly a sign convention and the development does not require flow in a single direction. The topographic slope is S_0 , assumed relatively constant in each reach, but can vary between reaches. The development of the unsteady flow equations herein uses several assumptions: 1. The pressure distribution at any section is hydrostatic ; this assumption allows computation of pressure force as a function of depth. 2. Wavelengths are long relative to flow depth; use the shallow wave theory. 3. Channel slopes are small enough so that the topographic slope is roughly equal to the tangent of the angle formed by the channel bottom and the horizontal. 4. The flow is one-dimensional ; this assumption implies that longitudinal dimension is large relative to cross sectional dimension. Generally river flows will meet this assumption, it fails in estuaries where the spatial dimensions (length and width) are roughly equal. Thus rivers that are hundreds of feet wide imply that reaches are miles long. If this assumption cannot be met, then 2-D methods are more appropriate.' 5. Friction is modeled by Chezy-Manning type empirical models. The particular friction model does not really matter, but historically these equations have used the friction slope concept as computed from one of these empirical models. The tools that are used to build the equations are conservation of mass and linear momentum. Conservation of Mass The conservation of mass in the cell is the statement that mass entering and leaving the cell is balanced by the accumulation or lass of mass within the cell. For pedagog- ical clarity, this section goes through each part of a mass balance then assembles into a difference equation of interest. Mass Entering : Mass enters from the left of the cell in our sketch. This direction only establishes a direction convention and negative flux means the arrow points in the direction opposite of that in the sketch. In the notation of the sketch mass entering in a short time interval is: \\dot M_{in} = \\rho \\cdot (Q -\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2}) \\cdot \\Delta t Mass Exiting : Mass leaves from the right of the cell in our sketch. In the notation of the sketch mass leaving is: \\dot M_{in} = \\rho \\cdot (Q +\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2}) \\cdot \\Delta t Mass Accumulating : Mass accumulating within the reach is stored in the prism depicted in the sketch by the dashed lines. The product of density and prism volume is the mass added to (or removed from) storage. The rise in water surface in a short time interval is \\frac{\\partial z}{\\partial t} \\cdot \\Delta t The plan view area of the prism is B(z) \\cdot \\Delta x . The product of these two terms is the mass added to storage, expressed as: \\dot M_{storage} = \\rho \\cdot (\\frac{\\partial z}{\\partial t} \\cdot \\Delta t) \\cdot B(z) \\cdot \\Delta x Equating the accumulation to the net inflow produces \\rho \\cdot (\\frac{\\partial z}{\\partial t} \\cdot \\Delta t) \\cdot B(z) \\cdot \\Delta x = \\rho \\cdot (Q -\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2}) \\cdot \\Delta t - \\rho \\cdot (Q +\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2}) \\cdot \\Delta t This is the mass balance equation for the reach. If the flow is isothermal, and essentially incompressible then the density is a constant and can be removed from both sides of the equation. (\\frac{\\partial z}{\\partial t} \\cdot \\Delta t) \\cdot B(z) \\cdot \\Delta x = (Q -\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2}) \\cdot \\Delta t - (Q +\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2}) \\cdot \\Delta t Remove the +Q and -Q and simplify the right hand side (\\frac{\\partial z}{\\partial t} \\cdot \\Delta t) \\cdot B(z) \\cdot \\Delta x = - (\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2}) \\cdot \\Delta t - (\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2}) \\cdot \\Delta t = - \\frac{\\partial Q}{\\partial x} \\cdot {\\Delta x} \\cdot \\Delta t Dividing both sides by \\Delta x \\cdot \\Delta t yields (\\frac{\\partial z}{\\partial t} ) \\cdot B(z) = - \\frac{\\partial Q}{\\partial x} This equation is the conventional representation of the conservation of mass in 1-D open channel flow. If the equation includes lateral inflow the equation is adjusted to include this additional mass term. The usual lateral in flow is treated as a discharge per unit length added into the mass balance as expressed as: (\\frac{\\partial z}{\\partial t} ) \\cdot B(z) + \\frac{\\partial Q}{\\partial x} = q This last equation is one of the two equations that comprise the St. Venant equations. The other equation is developed from the conservation of linear momentum. Conservation of Momentum The conservation of momentum is the statement of the change in momentum in the reach is equal to the net momentum entering the reach plus the sum of the forces on the water in the reach. As in the mass balance, each component will be considered separately for pedagogical clarity. Figure 2 is a sketch of the reach element under consideration, on some non-zero sloped surface. Figure 2 Equation of Motion Sketch Momentum Entering : Momentum entering on the left side of the sketch is: \\rho \\cdot QV = \\rho \\cdot V^2A Momentum Exiting : Momentum leaving on the right side of the sketch is: \\rho \\cdot QV + \\frac{\\partial}{\\partial x}(\\rho \\cdot QV)\\delta x = \\rho \\cdot V^2A + \\frac{\\partial}{\\partial x}(\\rho \\cdot V^2A)\\delta x Momentum Accumulating : The momentum accumulating is the rate of change of linear momentum: \\frac{dL}{dt} = \\frac{d(mV)}{dt} = \\frac{\\partial}{\\partial t} (\\rho \\cdot AV \\cdot \\delta x)=\\rho \\cdot \\delta x \\cdot \\frac{\\partial}{\\partial t} (AV) Gravity Force : The gravitational force on the element is the product of the mass in the element and the downslope component of acceleration. The mass in the element is \\rho A \\delta x The x-component of acceleration is g sin(\\alpha) , which is \\approx S_0 for small values of \\alpha . The resulting force of gravity is is the product of these two values: F_g = \\rho g AS_0 \\delta x Friction Force : Friction force is the product of the shear stress and the contact area. In the reach the contact area is the product of the reach length and average wetted perimeter. F_{f} = \\tau P_w \\delta x where Pw = A/R , where R is the hydraulic radius. A good approximation for shear stress in unsteady flow is \\tau = \\rho g R S_f . The value S_f is the slope of the energy grade line at some instant and is also called the friction slope. This slope can be empirically determined by a variety of models, typically Chezy's or Manning's equation is used. In either of these two models, we are using the STEADY FLOW equation of motion to mimic unsteady behavior - nothing wrong, and it is common practice, but this decision does limit the frequency response of the model (the ability to change fast - hence the shallow wave theory assumption!). The resulting friction model is F_{f} = \\rho g A S_f \\delta x Pressure Force : The pressure forces are comprized of the pressure applied at the end faces of the reach, and along the channel sides. Figure 3 is a sketch that depicts a panel of a cross section that is integrated vertically to obtain pressure magnitude. Figure 3 Pressure-Integral Sketch F_p = \\int_A dF where dF = (z-h)\\rho g \\xi (h) dh where \\xi (h) is the width panel at a given distance above the channel bottom (h) at any section. The net forceis the differnece in the upstream and downstream forces: F_{p~net} = F_{p~up} - F_{p~down} = F_p - (F_p + \\frac{\\partial F_p}{\\partial x}\\cdot \\delta x) = - \\frac{\\partial F_p}{\\partial x}\\cdot \\delta x when expressedusing the integral: - \\frac{\\partial F_p}{\\partial x}\\cdot \\delta x = - \\frac{\\partial}{\\partial x}[\\int_0^Z \\rho g (z-h) \\xi(h) dh]\\delta x evaluating by parts F_{p~net} = - \\rho g [\\frac{\\partial z}{\\partial x}\\int_0^Z \\xi(h) dh + \\int_0^Z (z-h) \\xi(h) \\frac{\\partial \\xi(h)}{\\partial x} dh]\\delta x The first term integrates to the cross sectional area, the second term is the variation in pressure with position along the channel. The other pressure force to consider is the bank force (the pressure force exerted by the banks on the element). This force is computed using the same type of integral structure except the integrand order is swapped. F_{p~bank} = [\\int_0^Z (z-h) \\xi(h) \\frac{\\partial \\xi(h)}{\\partial x} \\delta x]dh Now to combine the parts into a momentum balance: Momentum_{in} - Momentum_{out} + \\sum F = \\frac{d(mV)}{dt} Substitution of the pieces : Momentum_{in} - Momentum_{out} + F_{p~net} + F_{bank} + F_{gravity} - F_{friction} = \\frac{d(mV)}{dt} Now write the expressions for each expressions for each part: \\rho \\cdot V^2A - \\rho \\cdot V^2A - \\frac{\\partial}{\\partial x}(\\rho \\cdot V^2A)\\delta x \\\\ - \\rho g [\\frac{\\partial z}{\\partial x}\\int_0^Z \\xi(h) dh - \\int_0^Z (z-h) \\xi(h) \\frac{\\partial \\xi(h)}{\\partial x} dh]\\delta x \\\\ + [\\int_0^Z (z-h) \\xi(h) \\frac{\\partial \\xi(h)}{\\partial x} \\delta x]dh \\\\ + \\rho g AS_0 \\delta x \\\\ - \\rho g A S_f \\delta x \\\\ = \\rho \\cdot \\delta x \\cdot \\frac{\\partial}{\\partial t} (AV) The rows above, in order represent: 1. Net momentum entering the reach. 2. Pressure force differential at the end sections. 3. Pressure force on the channel sides. 4. Gravitational force. 5. Frictional force opposing flow. 6. Total acceleration in the reach (as change in linear momentum). Simplifications Canceling terms and dividing by \\rho \\delta x (isothermal, incompressible flow; reach has finite length), The momentum equation simplifies to: -\\frac{\\partial }{\\partial x}(V^2 A) - g \\frac{\\partial z}{\\partial x}\\int_0^Z \\xi(h) dh + g A S_0 - g R S_f = \\frac{\\partial }{\\partial t}(AV) The second term integral is the sectional flow area, so it simplifies to -\\frac{\\partial }{\\partial x}(V^2 A) - g \\frac{\\partial z}{\\partial x}A + g A S_0 - g A S_f = \\frac{\\partial }{\\partial t}(AV) The term with the square of mean section velocity is expanded by the chain rule ( https://www.youtube.com/watch?v=H-ybCx8gt-8 ), and using continunity becomes (notice the convective acceleration term from the change in area with time) -\\frac{\\partial }{\\partial t}(AV) = A \\frac{\\partial V}{\\partial t} + V \\frac{\\partial A}{\\partial t} = A \\frac{\\partial V}{\\partial t} - VA \\frac{\\partial V }{\\partial x} - V^2 \\frac{\\partial A}{\\partial x} Now expand and construct -V^2 \\frac{\\partial A}{\\partial x} -2VA \\frac{\\partial V}{\\partial x} - g A \\frac{\\partial z}{\\partial x} + g A (S_0 - S_f) = A \\frac{\\partial V}{\\partial t} - VA \\frac{\\partial V}{\\partial x} - V^2 \\frac{\\partial A}{\\partial x} Cancel common terms and simplify -VA \\frac{\\partial V}{\\partial x} - g A \\frac{\\partial z}{\\partial x} + g A (S_0 - S_f) = A \\frac{\\partial V}{\\partial t} The above equation is the form of the momentum equation for practical use. It will be rearranged in the remainder of this essay to fit some other purposes, but this is the expression of momentum in the channel reach. A bit more manipulation (divide by gA ) -\\frac{V}{g}\\frac{\\partial V}{\\partial x} - \\frac{\\partial z}{\\partial x} + (S_0 - S_f) = \\frac{1}{g} \\frac{\\partial V}{\\partial t} Now rearrange to place the two slopes on the left side, and the remaining part of momentum to the right side. The result let's us examine the several flow regimes common in open channel flows. S_0 - S_f = \\frac{1}{g} \\frac{\\partial V}{\\partial t} + \\frac{\\partial z}{\\partial x} + \\frac{V}{g}\\frac{\\partial V}{\\partial x} If the local acceleration (first term on the right) is zero, the depth taper (middle term on the right) is zero, and the convective acceleration (last term on the right) is zero, then the expression degenerates to the algebraic equation of normal flow ( S_0 = S_f ). If just the local acceleration term is zero, and all the remaining terms are considered, then the expression degenerates to the ordinary differential equation of gradually varied flow. Finally, if all the terms are retained, then the dynamic flow (shallow wave) conditions are in effect and the resulting model is a partial differential equation. Flow Regimes Re-iterating these typical ow regimes. 1. Uniform flow; algebraic equation. S_f = S_0 Gradually varied; ordinary differential equation. S_f = S_0 - \\frac{\\partial z}{\\partial x} - \\frac{V}{g}\\frac{\\partial V}{\\partial x} Dynamic flow (shallow wave) conditions; partial differential equation. S_f = S_0 - \\frac{1}{g} \\frac{\\partial V}{\\partial t} - \\frac{\\partial z}{\\partial x} - \\frac{V}{g}\\frac{\\partial V}{\\partial x} The coupled pair of equations, for continuity and for momentum are called the St. Venant equations and comprise a coupled hyperbolic differential equation system. A. Continunity (\\frac{\\partial z}{\\partial t} ) \\cdot B(z) + \\frac{\\partial Q}{\\partial x} = q B. Momentum S_0 - S_f = \\frac{1}{g} \\frac{\\partial V}{\\partial t} + \\frac{\\partial z}{\\partial x} + \\frac{V}{g}\\frac{\\partial V}{\\partial x} Solutions ( (z, t) and (V, t) functions) are found by a variety of methods including finite difference, finite element, finite volume, and characteristics methods. In the next lesson we will examine solutions to the gradually varied flow equation, then proceed to a finite difference solution to the full dynamic equations in the following chapter. References Koutitas, C. G. 1983. Elements of Computational Hydraulics. ISBN 0-412-00361-9. Pentech Press Ltd. London. (Chapter 4) Roberson, J. A., Cassidy, J.J., and Chaudry, M. H., (1988) Hydraulic Engineering, Houghton Mifflin Co (Chapter 10) Sturm T.W (2001) Open Channel Hydraulics, 1ed., McGraw-Hill, New York. Note: This PDF is from an international edition published in Singapore.","title":"Part 2 St. Venant Equations"},{"location":"lesson2/ce5362-swmodeling-lesson-2.2/#ce-5362-lesson-2-hydraulics-review","text":"Open Channel Hydraulics (A Review) 1D Spatial: St. Venant Equations Gradually Varied Flow Water Surface Profiles by Variable Step Water Surface Profiles by Fixed Step","title":"CE 5362 Lesson 2 Hydraulics Review"},{"location":"lesson2/ce5362-swmodeling-lesson-2.2/#st-venant-equations","text":"In general, 1-D unsteady flow would be considered state-of-practice computation; every engineer would be expected to be able to make such calculations (using professional software). 2-D computation is becoming routine using general purpose software. 3-D computation as of this writing (circa 2009) is still in the realm of state-of-art, and may not be within the capability a typical consulting firm. The conservation of mass, momentum, and energy in the context of the cell balance method is used herein to develop the mathematical and computational structure. The cell balance is a computational structure that is somewhat analogous to the Reynolds transport theorem, except the end results are difference equations that can be updates to approximate physical processes. The philosophy is a hybrid approach - instead of developing the differential equations first, then numerical approximations, the numerical constructs are built directly and the limiting process is employed to demonstrate that the constructs indeed mimic the differential equations that describe our current understanding of the physics.","title":"St. Venant Equations"},{"location":"lesson2/ce5362-swmodeling-lesson-2.2/#the-computational-cell","text":"The cell balance method envisions the world as representable by a computational cell (or more typically a collection of cells) with some finite dimension, fixed in space about a cell centroid. Some dimensions are changeable - such as depth. The fundamental computational element is a computational cell or a reach. Some professional software, in particular HEC-RAS, considers a reach to be a specific portion of a river system that may be comprised of several computational sub-reaches (cells). The engineer will need to consider the context and the tool used to decide which way to describe their problem to the program (and to the client). Figure 1 is a sketch of a portion of a channel. The left-most section is uphill (and upstream) of the right-most section. The section geometry is arbitrary, but is drawn to look like a channel cross section. Figure 1 Reach/Computational Cell The length of the reach (distance between each section along the flow path) is \\Delta x . The depth of liquid in the section is z , the width at the free surface is B(z) , the functional relationship established by the channel geometry. The flow into the reach on the upstream face is Q -\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2} The flow out of the reach on the downstream face Q +\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2} . The direction is strictly a sign convention and the development does not require flow in a single direction. The topographic slope is S_0 , assumed relatively constant in each reach, but can vary between reaches. The development of the unsteady flow equations herein uses several assumptions: 1. The pressure distribution at any section is hydrostatic ; this assumption allows computation of pressure force as a function of depth. 2. Wavelengths are long relative to flow depth; use the shallow wave theory. 3. Channel slopes are small enough so that the topographic slope is roughly equal to the tangent of the angle formed by the channel bottom and the horizontal. 4. The flow is one-dimensional ; this assumption implies that longitudinal dimension is large relative to cross sectional dimension. Generally river flows will meet this assumption, it fails in estuaries where the spatial dimensions (length and width) are roughly equal. Thus rivers that are hundreds of feet wide imply that reaches are miles long. If this assumption cannot be met, then 2-D methods are more appropriate.' 5. Friction is modeled by Chezy-Manning type empirical models. The particular friction model does not really matter, but historically these equations have used the friction slope concept as computed from one of these empirical models. The tools that are used to build the equations are conservation of mass and linear momentum.","title":"The Computational Cell"},{"location":"lesson2/ce5362-swmodeling-lesson-2.2/#conservation-of-mass","text":"The conservation of mass in the cell is the statement that mass entering and leaving the cell is balanced by the accumulation or lass of mass within the cell. For pedagog- ical clarity, this section goes through each part of a mass balance then assembles into a difference equation of interest. Mass Entering : Mass enters from the left of the cell in our sketch. This direction only establishes a direction convention and negative flux means the arrow points in the direction opposite of that in the sketch. In the notation of the sketch mass entering in a short time interval is: \\dot M_{in} = \\rho \\cdot (Q -\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2}) \\cdot \\Delta t Mass Exiting : Mass leaves from the right of the cell in our sketch. In the notation of the sketch mass leaving is: \\dot M_{in} = \\rho \\cdot (Q +\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2}) \\cdot \\Delta t Mass Accumulating : Mass accumulating within the reach is stored in the prism depicted in the sketch by the dashed lines. The product of density and prism volume is the mass added to (or removed from) storage. The rise in water surface in a short time interval is \\frac{\\partial z}{\\partial t} \\cdot \\Delta t The plan view area of the prism is B(z) \\cdot \\Delta x . The product of these two terms is the mass added to storage, expressed as: \\dot M_{storage} = \\rho \\cdot (\\frac{\\partial z}{\\partial t} \\cdot \\Delta t) \\cdot B(z) \\cdot \\Delta x Equating the accumulation to the net inflow produces \\rho \\cdot (\\frac{\\partial z}{\\partial t} \\cdot \\Delta t) \\cdot B(z) \\cdot \\Delta x = \\rho \\cdot (Q -\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2}) \\cdot \\Delta t - \\rho \\cdot (Q +\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2}) \\cdot \\Delta t This is the mass balance equation for the reach. If the flow is isothermal, and essentially incompressible then the density is a constant and can be removed from both sides of the equation. (\\frac{\\partial z}{\\partial t} \\cdot \\Delta t) \\cdot B(z) \\cdot \\Delta x = (Q -\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2}) \\cdot \\Delta t - (Q +\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2}) \\cdot \\Delta t Remove the +Q and -Q and simplify the right hand side (\\frac{\\partial z}{\\partial t} \\cdot \\Delta t) \\cdot B(z) \\cdot \\Delta x = - (\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2}) \\cdot \\Delta t - (\\frac{\\partial Q}{\\partial x}\\frac{\\Delta x}{2}) \\cdot \\Delta t = - \\frac{\\partial Q}{\\partial x} \\cdot {\\Delta x} \\cdot \\Delta t Dividing both sides by \\Delta x \\cdot \\Delta t yields (\\frac{\\partial z}{\\partial t} ) \\cdot B(z) = - \\frac{\\partial Q}{\\partial x} This equation is the conventional representation of the conservation of mass in 1-D open channel flow. If the equation includes lateral inflow the equation is adjusted to include this additional mass term. The usual lateral in flow is treated as a discharge per unit length added into the mass balance as expressed as: (\\frac{\\partial z}{\\partial t} ) \\cdot B(z) + \\frac{\\partial Q}{\\partial x} = q This last equation is one of the two equations that comprise the St. Venant equations. The other equation is developed from the conservation of linear momentum.","title":"Conservation of Mass"},{"location":"lesson2/ce5362-swmodeling-lesson-2.2/#conservation-of-momentum","text":"The conservation of momentum is the statement of the change in momentum in the reach is equal to the net momentum entering the reach plus the sum of the forces on the water in the reach. As in the mass balance, each component will be considered separately for pedagogical clarity. Figure 2 is a sketch of the reach element under consideration, on some non-zero sloped surface. Figure 2 Equation of Motion Sketch Momentum Entering : Momentum entering on the left side of the sketch is: \\rho \\cdot QV = \\rho \\cdot V^2A Momentum Exiting : Momentum leaving on the right side of the sketch is: \\rho \\cdot QV + \\frac{\\partial}{\\partial x}(\\rho \\cdot QV)\\delta x = \\rho \\cdot V^2A + \\frac{\\partial}{\\partial x}(\\rho \\cdot V^2A)\\delta x Momentum Accumulating : The momentum accumulating is the rate of change of linear momentum: \\frac{dL}{dt} = \\frac{d(mV)}{dt} = \\frac{\\partial}{\\partial t} (\\rho \\cdot AV \\cdot \\delta x)=\\rho \\cdot \\delta x \\cdot \\frac{\\partial}{\\partial t} (AV) Gravity Force : The gravitational force on the element is the product of the mass in the element and the downslope component of acceleration. The mass in the element is \\rho A \\delta x The x-component of acceleration is g sin(\\alpha) , which is \\approx S_0 for small values of \\alpha . The resulting force of gravity is is the product of these two values: F_g = \\rho g AS_0 \\delta x Friction Force : Friction force is the product of the shear stress and the contact area. In the reach the contact area is the product of the reach length and average wetted perimeter. F_{f} = \\tau P_w \\delta x where Pw = A/R , where R is the hydraulic radius. A good approximation for shear stress in unsteady flow is \\tau = \\rho g R S_f . The value S_f is the slope of the energy grade line at some instant and is also called the friction slope. This slope can be empirically determined by a variety of models, typically Chezy's or Manning's equation is used. In either of these two models, we are using the STEADY FLOW equation of motion to mimic unsteady behavior - nothing wrong, and it is common practice, but this decision does limit the frequency response of the model (the ability to change fast - hence the shallow wave theory assumption!). The resulting friction model is F_{f} = \\rho g A S_f \\delta x Pressure Force : The pressure forces are comprized of the pressure applied at the end faces of the reach, and along the channel sides. Figure 3 is a sketch that depicts a panel of a cross section that is integrated vertically to obtain pressure magnitude. Figure 3 Pressure-Integral Sketch F_p = \\int_A dF where dF = (z-h)\\rho g \\xi (h) dh where \\xi (h) is the width panel at a given distance above the channel bottom (h) at any section. The net forceis the differnece in the upstream and downstream forces: F_{p~net} = F_{p~up} - F_{p~down} = F_p - (F_p + \\frac{\\partial F_p}{\\partial x}\\cdot \\delta x) = - \\frac{\\partial F_p}{\\partial x}\\cdot \\delta x when expressedusing the integral: - \\frac{\\partial F_p}{\\partial x}\\cdot \\delta x = - \\frac{\\partial}{\\partial x}[\\int_0^Z \\rho g (z-h) \\xi(h) dh]\\delta x evaluating by parts F_{p~net} = - \\rho g [\\frac{\\partial z}{\\partial x}\\int_0^Z \\xi(h) dh + \\int_0^Z (z-h) \\xi(h) \\frac{\\partial \\xi(h)}{\\partial x} dh]\\delta x The first term integrates to the cross sectional area, the second term is the variation in pressure with position along the channel. The other pressure force to consider is the bank force (the pressure force exerted by the banks on the element). This force is computed using the same type of integral structure except the integrand order is swapped. F_{p~bank} = [\\int_0^Z (z-h) \\xi(h) \\frac{\\partial \\xi(h)}{\\partial x} \\delta x]dh Now to combine the parts into a momentum balance: Momentum_{in} - Momentum_{out} + \\sum F = \\frac{d(mV)}{dt} Substitution of the pieces : Momentum_{in} - Momentum_{out} + F_{p~net} + F_{bank} + F_{gravity} - F_{friction} = \\frac{d(mV)}{dt} Now write the expressions for each expressions for each part: \\rho \\cdot V^2A - \\rho \\cdot V^2A - \\frac{\\partial}{\\partial x}(\\rho \\cdot V^2A)\\delta x \\\\ - \\rho g [\\frac{\\partial z}{\\partial x}\\int_0^Z \\xi(h) dh - \\int_0^Z (z-h) \\xi(h) \\frac{\\partial \\xi(h)}{\\partial x} dh]\\delta x \\\\ + [\\int_0^Z (z-h) \\xi(h) \\frac{\\partial \\xi(h)}{\\partial x} \\delta x]dh \\\\ + \\rho g AS_0 \\delta x \\\\ - \\rho g A S_f \\delta x \\\\ = \\rho \\cdot \\delta x \\cdot \\frac{\\partial}{\\partial t} (AV) The rows above, in order represent: 1. Net momentum entering the reach. 2. Pressure force differential at the end sections. 3. Pressure force on the channel sides. 4. Gravitational force. 5. Frictional force opposing flow. 6. Total acceleration in the reach (as change in linear momentum).","title":"Conservation of Momentum"},{"location":"lesson2/ce5362-swmodeling-lesson-2.2/#simplifications","text":"Canceling terms and dividing by \\rho \\delta x (isothermal, incompressible flow; reach has finite length), The momentum equation simplifies to: -\\frac{\\partial }{\\partial x}(V^2 A) - g \\frac{\\partial z}{\\partial x}\\int_0^Z \\xi(h) dh + g A S_0 - g R S_f = \\frac{\\partial }{\\partial t}(AV) The second term integral is the sectional flow area, so it simplifies to -\\frac{\\partial }{\\partial x}(V^2 A) - g \\frac{\\partial z}{\\partial x}A + g A S_0 - g A S_f = \\frac{\\partial }{\\partial t}(AV) The term with the square of mean section velocity is expanded by the chain rule ( https://www.youtube.com/watch?v=H-ybCx8gt-8 ), and using continunity becomes (notice the convective acceleration term from the change in area with time) -\\frac{\\partial }{\\partial t}(AV) = A \\frac{\\partial V}{\\partial t} + V \\frac{\\partial A}{\\partial t} = A \\frac{\\partial V}{\\partial t} - VA \\frac{\\partial V }{\\partial x} - V^2 \\frac{\\partial A}{\\partial x} Now expand and construct -V^2 \\frac{\\partial A}{\\partial x} -2VA \\frac{\\partial V}{\\partial x} - g A \\frac{\\partial z}{\\partial x} + g A (S_0 - S_f) = A \\frac{\\partial V}{\\partial t} - VA \\frac{\\partial V}{\\partial x} - V^2 \\frac{\\partial A}{\\partial x} Cancel common terms and simplify -VA \\frac{\\partial V}{\\partial x} - g A \\frac{\\partial z}{\\partial x} + g A (S_0 - S_f) = A \\frac{\\partial V}{\\partial t} The above equation is the form of the momentum equation for practical use. It will be rearranged in the remainder of this essay to fit some other purposes, but this is the expression of momentum in the channel reach. A bit more manipulation (divide by gA ) -\\frac{V}{g}\\frac{\\partial V}{\\partial x} - \\frac{\\partial z}{\\partial x} + (S_0 - S_f) = \\frac{1}{g} \\frac{\\partial V}{\\partial t} Now rearrange to place the two slopes on the left side, and the remaining part of momentum to the right side. The result let's us examine the several flow regimes common in open channel flows. S_0 - S_f = \\frac{1}{g} \\frac{\\partial V}{\\partial t} + \\frac{\\partial z}{\\partial x} + \\frac{V}{g}\\frac{\\partial V}{\\partial x} If the local acceleration (first term on the right) is zero, the depth taper (middle term on the right) is zero, and the convective acceleration (last term on the right) is zero, then the expression degenerates to the algebraic equation of normal flow ( S_0 = S_f ). If just the local acceleration term is zero, and all the remaining terms are considered, then the expression degenerates to the ordinary differential equation of gradually varied flow. Finally, if all the terms are retained, then the dynamic flow (shallow wave) conditions are in effect and the resulting model is a partial differential equation.","title":"Simplifications"},{"location":"lesson2/ce5362-swmodeling-lesson-2.2/#flow-regimes","text":"Re-iterating these typical ow regimes. 1. Uniform flow; algebraic equation. S_f = S_0 Gradually varied; ordinary differential equation. S_f = S_0 - \\frac{\\partial z}{\\partial x} - \\frac{V}{g}\\frac{\\partial V}{\\partial x} Dynamic flow (shallow wave) conditions; partial differential equation. S_f = S_0 - \\frac{1}{g} \\frac{\\partial V}{\\partial t} - \\frac{\\partial z}{\\partial x} - \\frac{V}{g}\\frac{\\partial V}{\\partial x} The coupled pair of equations, for continuity and for momentum are called the St. Venant equations and comprise a coupled hyperbolic differential equation system. A. Continunity (\\frac{\\partial z}{\\partial t} ) \\cdot B(z) + \\frac{\\partial Q}{\\partial x} = q B. Momentum S_0 - S_f = \\frac{1}{g} \\frac{\\partial V}{\\partial t} + \\frac{\\partial z}{\\partial x} + \\frac{V}{g}\\frac{\\partial V}{\\partial x} Solutions ( (z, t) and (V, t) functions) are found by a variety of methods including finite difference, finite element, finite volume, and characteristics methods. In the next lesson we will examine solutions to the gradually varied flow equation, then proceed to a finite difference solution to the full dynamic equations in the following chapter.","title":"Flow Regimes"},{"location":"lesson2/ce5362-swmodeling-lesson-2.2/#references","text":"Koutitas, C. G. 1983. Elements of Computational Hydraulics. ISBN 0-412-00361-9. Pentech Press Ltd. London. (Chapter 4) Roberson, J. A., Cassidy, J.J., and Chaudry, M. H., (1988) Hydraulic Engineering, Houghton Mifflin Co (Chapter 10) Sturm T.W (2001) Open Channel Hydraulics, 1ed., McGraw-Hill, New York. Note: This PDF is from an international edition published in Singapore.","title":"References"},{"location":"lesson5/ce5362-swmodeling-lesson-5/","text":"CE 5362 Lesson 5 Computational Workshop This computational workshop is to examine computation related to: Uniform flow; algebraic equation. S_f = S_0 Gradually varied; ordinary differential equation. S_f = S_0 - \\frac{\\partial z}{\\partial x} - \\frac{V}{g}\\frac{\\partial V}{\\partial x} Dynamic flow (shallow wave) conditions; partial differential equation. S_f = S_0 - \\frac{1}{g} \\frac{\\partial V}{\\partial t} - \\frac{\\partial z}{\\partial x} - \\frac{V}{g}\\frac{\\partial V}{\\partial x} The objectives are to explore the JupyterLab environment to make relevant computations, then compare results to the professional tools (SWMM) Steady Uniform (Normal) Flow Uniform flow is defined as the situation where friction slope and channel slope are the same. In this kind of flow the profile grade line (channel bottom), the hydraulic grade line (water surface), and the energy grade line are all parallel: S_f = \\frac{\\Delta h}{\\Delta x} = S_0 One can apply the Darcy-Weisbach head loss model (adapted for non-circular conduits, using correlations for the friction factor): h_L = f\\frac{L}{4R_h}\\frac{V^2}{2g} or more commonly the Chezy-Manning head loss model: h_L = L (\\frac{n V}{1.0 \\times R_h^{2/3}})^2 Typical Calculations Uniform flow type computations will usually deal with flow depth in a given geometry for a given discharge, possibly from a hydrologic response model integrated into the process. Using that as the structure, lets build a simple, extensible model tool that predicts flow depth in a rectangular channel, and then computes node depths at the channel ends - we will then connect two channels in series (as we might in SWMM) and compute the predicted water surface elevation. First lets define some useful functions # Hydraulic Functions # Depth-Area function for rectangular channel def area(depth,width): area=depth*width; return(area) # Depth-Wetted perimeter function for rectangular channel def perimeter(depth,width): perimeter=2*depth+width; return(perimeter) # Hydraulic radius function def radius(area,perimeter): radius=area/perimeter; return(radius) # Topographic slope function def slope0(xup,zup,xdown,zdown): slope0=-1.0*(zdown-zup)/(xdown-xup) return(slope0) # Manning's equation SI units def qnorm(mannings_n,area,radius,slope): qnorm=(1.0/mannings_n)*area*(radius**(2./3.))*(slope**(1./2.)) return(qnorm) Here is how we might proceede, lets make up a function and check it width = 5.0 qdesign = 10.0 mannn = 0.02 z1 = 100.0 z2 = 99.0 x1 = 0.0 x2 = 100.0 toposlope = slope0(x1,z1,x2,z2) dguess = 0.63148039217297 qguess = qnorm(mannn,area(dguess,width),radius(area(dguess,width),perimeter(dguess,width)),toposlope) print('qdesign = ',qdesign,'qguess = ',qguess) qdesign = 10.0 qguess = 10.0 Now we will want to automate the process somewhat, here we use a quasi-Newton method as described at (http://54.243.252.9/engr-1330-psuedo-course/MyJupyterNotebooks/10-NewtonsMethod/NewtonsMethod.html) # Define the function def func(dguess): global x1,x2,z1,z2,mann,qdesign qguess = qnorm(mannn,area(dguess,width),radius(area(dguess,width),perimeter(dguess,width)),slope0(x1,z1,x2,z2)) func = qdesign - qguess return func def dfdx(x): dfdx = (func(x + 1e-06) - func(x) )/ (1e-06) return (dfdx) HowMany = 9 HowSmall = 1e-06 xnow = 0.5 # now we begin the process count = 0 for i in range(0,HowMany,1): xnew = xnow - func(xnow)/dfdx(xnow) # stopping criteria -- update not changing if abs(xnew - xnow) < HowSmall: print (\"Update not changing \\n\") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) break else: xnow = xnew count = count +1 continue # stopping criteria -- function close to zero if abs( func(xnew) ) < HowSmall: print (\"Function value close to zero \\n\") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) break else: xnow = xnew count = count +1 continue # next step, then have either broken from the loop or iteration counted out if count == HowMany: print(\" Iteration Limit Reached \") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) print(\"End of NewtonMethod.py \") Update not changing Function value = 0.0 Root value = 0.63148039217297 End of NewtonMethod.py Now we can tidy up the code a bit to handle an example case of 3 nodes, connected by two links. First lets convert the script to report specific output # Define the function def func(dguess): global x1,x2,z1,z2,mann,qdesign qguess = qnorm(mannn,area(dguess,width),radius(area(dguess,width),perimeter(dguess,width)),slope0(x1,z1,x2,z2)) func = qdesign - qguess return func def dfdx(x): dfdx = (func(x + 1e-06) - func(x) )/ (1e-06) return (dfdx) def GetDepth(xnow): HowMany = 9 HowSmall = 1e-06 #xnow = 0.5 #pass as argument # now we begin the process count = 0 for i in range(0,HowMany,1): xnew = xnow - func(xnow)/dfdx(xnow) # stopping criteria -- update not changing if abs(xnew - xnow) < HowSmall: print (\"Update not changing \\n\") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) break else: xnow = xnew count = count +1 continue # stopping criteria -- function close to zero if abs( func(xnew) ) < HowSmall: print (\"Function value close to zero \\n\") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) break else: xnow = xnew count = count +1 continue # next step, then have either broken from the loop or iteration counted out if count == HowMany: print(\" Iteration Limit Reached \") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) print(\"End of NewtonMethod.py \") return(xnew) GetDepth(0.5) Update not changing Function value = 0.0 Root value = 0.63148039217297 End of NewtonMethod.py 0.63148039217297 # Our world location = [0,100,200] elevation = [100,99,96] # bottom elevation nodes 0,1,2 - notice intended change in slope depth = [] head = [] mannn = 0.02 # mannings N all sections qdesign = 10.0 # upstream input flow # solve the first reach z1 = elevation[0] z2 = elevation[1] x1 = location[0] x2 = location[1] depth.append(GetDepth(0.5)) # solve the second reach z1 = elevation[1] z2 = elevation[2] x1 = location[1] x2 = location[2] depth.append(GetDepth(0.5)) # compute head in nodes (this is tricky at the slope change, probably use average head) head.append(elevation[0]+0.5*(depth[0]+depth[0])) head.append(elevation[1]+0.5*(depth[0]+depth[1])) head.append(elevation[2]+0.5*(depth[1]+depth[1])) print('') for irow in range(0,3): print('Node ',irow,' Elevation ',elevation[irow],' Water Surface Elevation ',head[irow]) Update not changing Function value = 0.0 Root value = 0.63148039217297 End of NewtonMethod.py Update not changing Function value = -1.7763568394002505e-15 Root value = 0.44303906911056373 End of NewtonMethod.py Node 0 Elevation 100 Water Surface Elevation 100.63148039217297 Node 1 Elevation 99 Water Surface Elevation 99.53725973064176 Node 2 Elevation 96 Water Surface Elevation 96.44303906911057 Now lets plot the situation # Now plotting def plotAline(list1,list2,list3,list4,strx,stry,strtitle): # plot list1 on x, list2 on y, xlabel, ylabel, title from matplotlib import pyplot as plt # import the plotting library from matplotlibplt.show() plt.plot( list1, list2, color ='brown', marker ='', linestyle ='solid') # create a line chart, years on x-axis, gdp on y-axis plt.plot( list3, list4, color ='blue', marker ='', linestyle ='solid') # create a line chart, years on x-axis, gdp on y-axis plt.title(strtitle)# add a title plt.ylabel(stry)# add a label to the x and y-axes plt.xlabel(strx) plt.show() # display the plot return #null return plotAline(location,elevation,location,head,'Distance','Elevation','Water Surface Profile - Normal Depth in Each Channel') SWMM Now we will do the same simulation in SWMM - we will find it is a lot easier to set-up and run. Gradually Varied Steady Flow Fixed Depth Change, Variable Spatial Step The fixed-step refers to specified changes in depth for which we solve to find the variable spatial steps. The method is a very simple method for computing water surface profiles in prismatic channels. A prismatic channel is a channel of uniform cross sectional geometry with constant bed (topographic) slope. In such channels with smooth (non-jump) steady flow the continunity and momentum equations are: Q = AV where where Q is volumetric discharge, A is cross sectional flow area, and V is the mean section velocity; and: \\frac{V}{g} \\frac{dV}{dx}+\\frac{dh}{dx} = S_o - S_f where h is the flow depth (above the bottom), and x is horizontal the distance along the channel. For the variable step method, the momentum equation is rewritten as a difference equation (after application of calculus to gather terms) then rearranged to solve for the spatial step dimension . \\frac{\\frac{V^2_{i+1}}{2g}-\\frac{V^2_{i}}{2g}}{\\Delta x} + \\frac{h_{i+1}-h_{i}}{\\Delta x} = S_o - \\bar{S_f} where S_f is the average slope of the energy grade line between two sections (along a reach of length \\Delta x , the unknown value). Rearrangement to isolate \\Delta x produces an explicit update equation that can be evaluated to find the different values of \\Delta x associated with different flow depths. The plot of the accumulated spatial changes versus the sum of the flow depth and bottom elevation is the water surface profile. \\frac{(h_{i+1} + \\frac{V^2_{i+1}}{2g}) - (h_{i} +\\frac{V^2_{i}}{2g}) }{S_o - \\bar{S_f} } = \\Delta x The distance between two sections with known discharges is computed using the equation, all the terms on the left hand side are known values. The mean energy gradient ( \\bar{S_f} ) is computed from the mean of the velocity, depth, area, and hydraulic radius for the two sections. The friction slope can be computed using Manning's, Chezy, or the Darcy-Weisbach friction equations adapted for non-circular, free-surface conduits. The equation here is written moving upstream, direction matters for indexing. Thus position i+1 is assumed upstream of position i in this notebook. Such directional convention is unusual in numerical methods and analysts need to use care when developing their own tools or using other tools. A clever analyst need not rewrite code, but simple interchange of upstream and downstream depths can handle both backwater and front-water curves. Scripting an Algorithm Here the method is illustrated in to illustrate the tool as a programming environment. First we build a set of utility functions, these will be used later in the backwater function The listings below are utility functions for rectangular channels for flow area given channel depth and width and wetted perimeter given depth and width. Different geometries will need different functions (probably by numerical methods rather than actual functional relationships). The first listing is a depth-area function for rectangular geometry. # Depth-Area function for rectangular channel def area(depth,width): area=depth*width; return(area) The next listing is a depth wetted-perimeter function for a rectangular geometry. # Depth-Wetted perimeter function for rectangular channel def perimeter(depth,width): perimeter=2*depth+width; return(perimeter) Listing below is a listing of the code for the hydraulic radius (ratio of the above results), this is a generic function, it does not need to know the flow geometry # Hydraulic radius function def radius(area,perimeter): radius=area/perimeter; return(radius) The next section is a listing of code for the friction slope given Manning's n, discharge, hydraulic radius, and flow area. This function implicitly assumes SI units (the 1.49 constant in U.S. Customary units is not present). For U.S. Customary units either add the constant or convert the US units into equivalent SI units. # Friction slope function def slope_f(discharge,mannings_n,area,radius): slope_f=(discharge**2)*(mannings_n**2)/( (radius**(4./3))*(area**2) ); #compute friction slope return(slope_f) # 2-point average def avg2point(x1,x2): avg2point=0.5*(x1+x2); return(avg2point) The semi-colons in the functions are probably unnecessary, but have value because it forces the expression to its left to be evaluated and helps prevent ambiguous code. Also notice the use of indention as a scope delimiter, the delimiter is required. Describe the actual BW computes At this point, we have 5 useful, testable functions (and we should test before the next step. The next listing is the step-backwater method implemented as a function. This function computes the space steps, changes in depth, etc. as per the algorithm. The function illustrates count controlled repetition (for loops), list indexing, and use of the utility functions to make the code readable as well as ensure that the parts work before the whole program is assembled. This concept is really crucial, if you can build a tool of parts that are known to work, it helps keep logic errors contained to known locations. # Backwater curve function def backwater(begin_depth,end_depth,how_many,discharge,width,mannings_n,slope): # ## Example function call ## zz<-backwater(begin_depth=8,end_depth=5,how_many=30,discharge=55.4,width=5,mannings_n=0.02,slope=0.001) ## Numerical values are values used in essay, they correspond to a particuar example from Koutitas 1983 # # Other functions must exist otherwise will spawn errors # # Prepare space for vectors twog=2.0*9.8 depth=[] # numeric vector for depths velocity=[] # numeric vector for velocities deltax=[] # numeric vector for spatial steps distance=[] # space for computing cumulative distances bse=[] # numeric vector for bottom elevations wse=[] # numeric vector for water surface elevations delta_depth=(begin_depth-end_depth)/(how_many) # change in depth for finding spatial steps #print(delta_depth) depth.append(begin_depth) # assign downstream value for i in range(1,how_many): depth.append(depth[0] - (i+1)*delta_depth) # uniform depths for i in range(0,how_many): velocity.append(discharge/area(depth[i],width)) for i in range(0,how_many-1): depth_bar=avg2point(depth[i+1],depth[i]); #compute average depth in reach area_bar=area(depth_bar,width); #compute average area in reach perimeter_bar=perimeter(depth_bar,width); #compute average wetted perimeter radius_bar=radius(area_bar,perimeter_bar); #compute average hydraulic radius friction=slope_f(discharge,mannings_n,area_bar,radius_bar) #compute friction slope snrgup =(depth[i+1]+((velocity[i+1]**2)/twog)) snrgdn =(depth[i] + ((velocity[i]**2)/twog)) step =(snrgup - snrgdn)/(slope-friction) # compute change in distance for each change in depth deltax.append(step) distance.append(0.0) bse.append(0.0) for i in range(1,how_many): distance.append(distance[i-1]+deltax[i-1]); # spatial distances bse.append(bse[i-1]-deltax[i-1]*slope); # bottom elevations for i in range(0,how_many): wse.append(bse[i]+depth[i]) # water surface elevations return(distance,wse,bse,depth,deltax,velocity) Function call with plotting # call the function - output is a tuple, use this fact in the plotting build output = backwater(begin_depth=8.0,end_depth=5.0,how_many=31,discharge=55.4,width=5.0,mannings_n=0.02,slope=0.001) # Now plot the water surface profile import matplotlib.pyplot myfigure = matplotlib.pyplot.figure(figsize = (16,8)) # generate a object from the figure class, set aspect ratio # Built the plot matplotlib.pyplot.plot(output[0], output[2], color ='brown', linewidth=3) matplotlib.pyplot.plot(output[0], output[1], color ='blue', linewidth=5) matplotlib.pyplot.ylabel(\"Elevation (meters)\") matplotlib.pyplot.xlabel(\"Distance (meters)\") mytitle = \"Water Surface Profile - Variable Spatial Step Method\" matplotlib.pyplot.title(mytitle) matplotlib.pyplot.show() References Koutitas, C. G. 1983. Elements of Computational Hydraulics. ISBN 0-412-00361-9. Pentech Press Ltd. London. (Chapter 4) http://54.243.252.9/ce-5362-psuedo-course/3-Readings/PracticalComputationalHydraulics-Kousitas/ElementsOfComputationalHydraulics.pdf Roberson, J. A., Cassidy, J.J., and Chaudry, M. H., (1988) Hydraulic Engineering, Houghton Mifflin Co (Chapter 10) http://54.243.252.9/ce-5362-psuedo-course/3-Readings/HydraulicEngineering/ Sturm T.W (2001) Open Channel Hydraulics, 1ed., McGraw-Hill, New York. Note: This PDF is from an international edition published in Singapore. http://54.243.252.9/ce-5362-psuedo-course/3-Readings/OpenChannelHYdraulics/ Cunge, J.A., Holly, F.M., Verwey, A. (1980). Practical Aspects of Computational River Hydraulics. Pittman Publishing Inc. , Boston, MA. pp. 7-50","title":"Lesson 5 GVF Variable Step-Backwater"},{"location":"lesson5/ce5362-swmodeling-lesson-5/#ce-5362-lesson-5-computational-workshop","text":"This computational workshop is to examine computation related to: Uniform flow; algebraic equation. S_f = S_0 Gradually varied; ordinary differential equation. S_f = S_0 - \\frac{\\partial z}{\\partial x} - \\frac{V}{g}\\frac{\\partial V}{\\partial x} Dynamic flow (shallow wave) conditions; partial differential equation. S_f = S_0 - \\frac{1}{g} \\frac{\\partial V}{\\partial t} - \\frac{\\partial z}{\\partial x} - \\frac{V}{g}\\frac{\\partial V}{\\partial x} The objectives are to explore the JupyterLab environment to make relevant computations, then compare results to the professional tools (SWMM)","title":"CE 5362 Lesson 5 Computational Workshop"},{"location":"lesson5/ce5362-swmodeling-lesson-5/#steady-uniform-normal-flow","text":"Uniform flow is defined as the situation where friction slope and channel slope are the same. In this kind of flow the profile grade line (channel bottom), the hydraulic grade line (water surface), and the energy grade line are all parallel: S_f = \\frac{\\Delta h}{\\Delta x} = S_0 One can apply the Darcy-Weisbach head loss model (adapted for non-circular conduits, using correlations for the friction factor): h_L = f\\frac{L}{4R_h}\\frac{V^2}{2g} or more commonly the Chezy-Manning head loss model: h_L = L (\\frac{n V}{1.0 \\times R_h^{2/3}})^2","title":"Steady Uniform (Normal) Flow"},{"location":"lesson5/ce5362-swmodeling-lesson-5/#typical-calculations","text":"Uniform flow type computations will usually deal with flow depth in a given geometry for a given discharge, possibly from a hydrologic response model integrated into the process. Using that as the structure, lets build a simple, extensible model tool that predicts flow depth in a rectangular channel, and then computes node depths at the channel ends - we will then connect two channels in series (as we might in SWMM) and compute the predicted water surface elevation. First lets define some useful functions # Hydraulic Functions # Depth-Area function for rectangular channel def area(depth,width): area=depth*width; return(area) # Depth-Wetted perimeter function for rectangular channel def perimeter(depth,width): perimeter=2*depth+width; return(perimeter) # Hydraulic radius function def radius(area,perimeter): radius=area/perimeter; return(radius) # Topographic slope function def slope0(xup,zup,xdown,zdown): slope0=-1.0*(zdown-zup)/(xdown-xup) return(slope0) # Manning's equation SI units def qnorm(mannings_n,area,radius,slope): qnorm=(1.0/mannings_n)*area*(radius**(2./3.))*(slope**(1./2.)) return(qnorm) Here is how we might proceede, lets make up a function and check it width = 5.0 qdesign = 10.0 mannn = 0.02 z1 = 100.0 z2 = 99.0 x1 = 0.0 x2 = 100.0 toposlope = slope0(x1,z1,x2,z2) dguess = 0.63148039217297 qguess = qnorm(mannn,area(dguess,width),radius(area(dguess,width),perimeter(dguess,width)),toposlope) print('qdesign = ',qdesign,'qguess = ',qguess) qdesign = 10.0 qguess = 10.0 Now we will want to automate the process somewhat, here we use a quasi-Newton method as described at (http://54.243.252.9/engr-1330-psuedo-course/MyJupyterNotebooks/10-NewtonsMethod/NewtonsMethod.html) # Define the function def func(dguess): global x1,x2,z1,z2,mann,qdesign qguess = qnorm(mannn,area(dguess,width),radius(area(dguess,width),perimeter(dguess,width)),slope0(x1,z1,x2,z2)) func = qdesign - qguess return func def dfdx(x): dfdx = (func(x + 1e-06) - func(x) )/ (1e-06) return (dfdx) HowMany = 9 HowSmall = 1e-06 xnow = 0.5 # now we begin the process count = 0 for i in range(0,HowMany,1): xnew = xnow - func(xnow)/dfdx(xnow) # stopping criteria -- update not changing if abs(xnew - xnow) < HowSmall: print (\"Update not changing \\n\") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) break else: xnow = xnew count = count +1 continue # stopping criteria -- function close to zero if abs( func(xnew) ) < HowSmall: print (\"Function value close to zero \\n\") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) break else: xnow = xnew count = count +1 continue # next step, then have either broken from the loop or iteration counted out if count == HowMany: print(\" Iteration Limit Reached \") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) print(\"End of NewtonMethod.py \") Update not changing Function value = 0.0 Root value = 0.63148039217297 End of NewtonMethod.py Now we can tidy up the code a bit to handle an example case of 3 nodes, connected by two links. First lets convert the script to report specific output # Define the function def func(dguess): global x1,x2,z1,z2,mann,qdesign qguess = qnorm(mannn,area(dguess,width),radius(area(dguess,width),perimeter(dguess,width)),slope0(x1,z1,x2,z2)) func = qdesign - qguess return func def dfdx(x): dfdx = (func(x + 1e-06) - func(x) )/ (1e-06) return (dfdx) def GetDepth(xnow): HowMany = 9 HowSmall = 1e-06 #xnow = 0.5 #pass as argument # now we begin the process count = 0 for i in range(0,HowMany,1): xnew = xnow - func(xnow)/dfdx(xnow) # stopping criteria -- update not changing if abs(xnew - xnow) < HowSmall: print (\"Update not changing \\n\") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) break else: xnow = xnew count = count +1 continue # stopping criteria -- function close to zero if abs( func(xnew) ) < HowSmall: print (\"Function value close to zero \\n\") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) break else: xnow = xnew count = count +1 continue # next step, then have either broken from the loop or iteration counted out if count == HowMany: print(\" Iteration Limit Reached \") print(\"Function value =\",func(xnew)) print(\" Root value =\",xnew) print(\"End of NewtonMethod.py \") return(xnew) GetDepth(0.5) Update not changing Function value = 0.0 Root value = 0.63148039217297 End of NewtonMethod.py 0.63148039217297 # Our world location = [0,100,200] elevation = [100,99,96] # bottom elevation nodes 0,1,2 - notice intended change in slope depth = [] head = [] mannn = 0.02 # mannings N all sections qdesign = 10.0 # upstream input flow # solve the first reach z1 = elevation[0] z2 = elevation[1] x1 = location[0] x2 = location[1] depth.append(GetDepth(0.5)) # solve the second reach z1 = elevation[1] z2 = elevation[2] x1 = location[1] x2 = location[2] depth.append(GetDepth(0.5)) # compute head in nodes (this is tricky at the slope change, probably use average head) head.append(elevation[0]+0.5*(depth[0]+depth[0])) head.append(elevation[1]+0.5*(depth[0]+depth[1])) head.append(elevation[2]+0.5*(depth[1]+depth[1])) print('') for irow in range(0,3): print('Node ',irow,' Elevation ',elevation[irow],' Water Surface Elevation ',head[irow]) Update not changing Function value = 0.0 Root value = 0.63148039217297 End of NewtonMethod.py Update not changing Function value = -1.7763568394002505e-15 Root value = 0.44303906911056373 End of NewtonMethod.py Node 0 Elevation 100 Water Surface Elevation 100.63148039217297 Node 1 Elevation 99 Water Surface Elevation 99.53725973064176 Node 2 Elevation 96 Water Surface Elevation 96.44303906911057 Now lets plot the situation # Now plotting def plotAline(list1,list2,list3,list4,strx,stry,strtitle): # plot list1 on x, list2 on y, xlabel, ylabel, title from matplotlib import pyplot as plt # import the plotting library from matplotlibplt.show() plt.plot( list1, list2, color ='brown', marker ='', linestyle ='solid') # create a line chart, years on x-axis, gdp on y-axis plt.plot( list3, list4, color ='blue', marker ='', linestyle ='solid') # create a line chart, years on x-axis, gdp on y-axis plt.title(strtitle)# add a title plt.ylabel(stry)# add a label to the x and y-axes plt.xlabel(strx) plt.show() # display the plot return #null return plotAline(location,elevation,location,head,'Distance','Elevation','Water Surface Profile - Normal Depth in Each Channel')","title":"Typical Calculations"},{"location":"lesson5/ce5362-swmodeling-lesson-5/#swmm","text":"Now we will do the same simulation in SWMM - we will find it is a lot easier to set-up and run.","title":"SWMM"},{"location":"lesson5/ce5362-swmodeling-lesson-5/#gradually-varied-steady-flow","text":"","title":"Gradually Varied Steady Flow"},{"location":"lesson5/ce5362-swmodeling-lesson-5/#fixed-depth-change-variable-spatial-step","text":"The fixed-step refers to specified changes in depth for which we solve to find the variable spatial steps. The method is a very simple method for computing water surface profiles in prismatic channels. A prismatic channel is a channel of uniform cross sectional geometry with constant bed (topographic) slope. In such channels with smooth (non-jump) steady flow the continunity and momentum equations are: Q = AV where where Q is volumetric discharge, A is cross sectional flow area, and V is the mean section velocity; and: \\frac{V}{g} \\frac{dV}{dx}+\\frac{dh}{dx} = S_o - S_f where h is the flow depth (above the bottom), and x is horizontal the distance along the channel. For the variable step method, the momentum equation is rewritten as a difference equation (after application of calculus to gather terms) then rearranged to solve for the spatial step dimension . \\frac{\\frac{V^2_{i+1}}{2g}-\\frac{V^2_{i}}{2g}}{\\Delta x} + \\frac{h_{i+1}-h_{i}}{\\Delta x} = S_o - \\bar{S_f} where S_f is the average slope of the energy grade line between two sections (along a reach of length \\Delta x , the unknown value). Rearrangement to isolate \\Delta x produces an explicit update equation that can be evaluated to find the different values of \\Delta x associated with different flow depths. The plot of the accumulated spatial changes versus the sum of the flow depth and bottom elevation is the water surface profile. \\frac{(h_{i+1} + \\frac{V^2_{i+1}}{2g}) - (h_{i} +\\frac{V^2_{i}}{2g}) }{S_o - \\bar{S_f} } = \\Delta x The distance between two sections with known discharges is computed using the equation, all the terms on the left hand side are known values. The mean energy gradient ( \\bar{S_f} ) is computed from the mean of the velocity, depth, area, and hydraulic radius for the two sections. The friction slope can be computed using Manning's, Chezy, or the Darcy-Weisbach friction equations adapted for non-circular, free-surface conduits. The equation here is written moving upstream, direction matters for indexing. Thus position i+1 is assumed upstream of position i in this notebook. Such directional convention is unusual in numerical methods and analysts need to use care when developing their own tools or using other tools. A clever analyst need not rewrite code, but simple interchange of upstream and downstream depths can handle both backwater and front-water curves.","title":"Fixed Depth Change, Variable Spatial Step"},{"location":"lesson5/ce5362-swmodeling-lesson-5/#scripting-an-algorithm","text":"Here the method is illustrated in to illustrate the tool as a programming environment. First we build a set of utility functions, these will be used later in the backwater function The listings below are utility functions for rectangular channels for flow area given channel depth and width and wetted perimeter given depth and width. Different geometries will need different functions (probably by numerical methods rather than actual functional relationships). The first listing is a depth-area function for rectangular geometry. # Depth-Area function for rectangular channel def area(depth,width): area=depth*width; return(area) The next listing is a depth wetted-perimeter function for a rectangular geometry. # Depth-Wetted perimeter function for rectangular channel def perimeter(depth,width): perimeter=2*depth+width; return(perimeter) Listing below is a listing of the code for the hydraulic radius (ratio of the above results), this is a generic function, it does not need to know the flow geometry # Hydraulic radius function def radius(area,perimeter): radius=area/perimeter; return(radius) The next section is a listing of code for the friction slope given Manning's n, discharge, hydraulic radius, and flow area. This function implicitly assumes SI units (the 1.49 constant in U.S. Customary units is not present). For U.S. Customary units either add the constant or convert the US units into equivalent SI units. # Friction slope function def slope_f(discharge,mannings_n,area,radius): slope_f=(discharge**2)*(mannings_n**2)/( (radius**(4./3))*(area**2) ); #compute friction slope return(slope_f) # 2-point average def avg2point(x1,x2): avg2point=0.5*(x1+x2); return(avg2point) The semi-colons in the functions are probably unnecessary, but have value because it forces the expression to its left to be evaluated and helps prevent ambiguous code. Also notice the use of indention as a scope delimiter, the delimiter is required.","title":"Scripting an Algorithm"},{"location":"lesson5/ce5362-swmodeling-lesson-5/#describe-the-actual-bw-computes","text":"At this point, we have 5 useful, testable functions (and we should test before the next step. The next listing is the step-backwater method implemented as a function. This function computes the space steps, changes in depth, etc. as per the algorithm. The function illustrates count controlled repetition (for loops), list indexing, and use of the utility functions to make the code readable as well as ensure that the parts work before the whole program is assembled. This concept is really crucial, if you can build a tool of parts that are known to work, it helps keep logic errors contained to known locations. # Backwater curve function def backwater(begin_depth,end_depth,how_many,discharge,width,mannings_n,slope): # ## Example function call ## zz<-backwater(begin_depth=8,end_depth=5,how_many=30,discharge=55.4,width=5,mannings_n=0.02,slope=0.001) ## Numerical values are values used in essay, they correspond to a particuar example from Koutitas 1983 # # Other functions must exist otherwise will spawn errors # # Prepare space for vectors twog=2.0*9.8 depth=[] # numeric vector for depths velocity=[] # numeric vector for velocities deltax=[] # numeric vector for spatial steps distance=[] # space for computing cumulative distances bse=[] # numeric vector for bottom elevations wse=[] # numeric vector for water surface elevations delta_depth=(begin_depth-end_depth)/(how_many) # change in depth for finding spatial steps #print(delta_depth) depth.append(begin_depth) # assign downstream value for i in range(1,how_many): depth.append(depth[0] - (i+1)*delta_depth) # uniform depths for i in range(0,how_many): velocity.append(discharge/area(depth[i],width)) for i in range(0,how_many-1): depth_bar=avg2point(depth[i+1],depth[i]); #compute average depth in reach area_bar=area(depth_bar,width); #compute average area in reach perimeter_bar=perimeter(depth_bar,width); #compute average wetted perimeter radius_bar=radius(area_bar,perimeter_bar); #compute average hydraulic radius friction=slope_f(discharge,mannings_n,area_bar,radius_bar) #compute friction slope snrgup =(depth[i+1]+((velocity[i+1]**2)/twog)) snrgdn =(depth[i] + ((velocity[i]**2)/twog)) step =(snrgup - snrgdn)/(slope-friction) # compute change in distance for each change in depth deltax.append(step) distance.append(0.0) bse.append(0.0) for i in range(1,how_many): distance.append(distance[i-1]+deltax[i-1]); # spatial distances bse.append(bse[i-1]-deltax[i-1]*slope); # bottom elevations for i in range(0,how_many): wse.append(bse[i]+depth[i]) # water surface elevations return(distance,wse,bse,depth,deltax,velocity)","title":"Describe the actual BW computes"},{"location":"lesson5/ce5362-swmodeling-lesson-5/#function-call-with-plotting","text":"# call the function - output is a tuple, use this fact in the plotting build output = backwater(begin_depth=8.0,end_depth=5.0,how_many=31,discharge=55.4,width=5.0,mannings_n=0.02,slope=0.001) # Now plot the water surface profile import matplotlib.pyplot myfigure = matplotlib.pyplot.figure(figsize = (16,8)) # generate a object from the figure class, set aspect ratio # Built the plot matplotlib.pyplot.plot(output[0], output[2], color ='brown', linewidth=3) matplotlib.pyplot.plot(output[0], output[1], color ='blue', linewidth=5) matplotlib.pyplot.ylabel(\"Elevation (meters)\") matplotlib.pyplot.xlabel(\"Distance (meters)\") mytitle = \"Water Surface Profile - Variable Spatial Step Method\" matplotlib.pyplot.title(mytitle) matplotlib.pyplot.show()","title":"Function call with plotting"},{"location":"lesson5/ce5362-swmodeling-lesson-5/#references","text":"Koutitas, C. G. 1983. Elements of Computational Hydraulics. ISBN 0-412-00361-9. Pentech Press Ltd. London. (Chapter 4) http://54.243.252.9/ce-5362-psuedo-course/3-Readings/PracticalComputationalHydraulics-Kousitas/ElementsOfComputationalHydraulics.pdf Roberson, J. A., Cassidy, J.J., and Chaudry, M. H., (1988) Hydraulic Engineering, Houghton Mifflin Co (Chapter 10) http://54.243.252.9/ce-5362-psuedo-course/3-Readings/HydraulicEngineering/ Sturm T.W (2001) Open Channel Hydraulics, 1ed., McGraw-Hill, New York. Note: This PDF is from an international edition published in Singapore. http://54.243.252.9/ce-5362-psuedo-course/3-Readings/OpenChannelHYdraulics/ Cunge, J.A., Holly, F.M., Verwey, A. (1980). Practical Aspects of Computational River Hydraulics. Pittman Publishing Inc. , Boston, MA. pp. 7-50","title":"References"},{"location":"lesson6/ce5362-swmodeling-lesson-6/","text":"CE 5362 Lesson 6 Computational Workshop This computational workshop is to examine computation related to: Uniform flow; algebraic equation. S_f = S_0 Gradually varied; ordinary differential equation. S_f = S_0 - \\frac{\\partial z}{\\partial x} - \\frac{V}{g}\\frac{\\partial V}{\\partial x} Dynamic flow (shallow wave) conditions; partial differential equation. S_f = S_0 - \\frac{1}{g} \\frac{\\partial V}{\\partial t} - \\frac{\\partial z}{\\partial x} - \\frac{V}{g}\\frac{\\partial V}{\\partial x} The objectives are to explore the JupyterLab environment to make relevant computations, then compare results to the professional tools (SWMM) Gradually Varied Steady Flow Fixed Depth Change, Variable Spatial Step The fixed-step refers to specified changes in depth for which we solve to find the variable spatial steps. The method is a very simple method for computing water surface profiles in prismatic channels. A prismatic channel is a channel of uniform cross sectional geometry with constant bed (topographic) slope. In such channels with smooth (non-jump) steady flow the continunity and momentum equations are: Q = AV where where Q is volumetric discharge, A is cross sectional flow area, and V is the mean section velocity; and: \\frac{V}{g} \\frac{dV}{dx}+\\frac{dh}{dx} = S_o - S_f where h is the flow depth (above the bottom), and x is horizontal the distance along the channel. For the variable step method, the momentum equation is rewritten as a difference equation (after application of calculus to gather terms) then rearranged to solve for the spatial step dimension . \\frac{\\frac{V^2_{i+1}}{2g}-\\frac{V^2_{i}}{2g}}{\\Delta x} + \\frac{h_{i+1}-h_{i}}{\\Delta x} = S_o - \\bar{S_f} where S_f is the average slope of the energy grade line between two sections (along a reach of length \\Delta x , the unknown value). Rearrangement to isolate \\Delta x produces an explicit update equation that can be evaluated to find the different values of \\Delta x associated with different flow depths. The plot of the accumulated spatial changes versus the sum of the flow depth and bottom elevation is the water surface profile. \\frac{(h_{i+1} + \\frac{V^2_{i+1}}{2g}) - (h_{i} +\\frac{V^2_{i}}{2g}) }{S_o - \\bar{S_f} } = \\Delta x The distance between two sections with known discharges is computed using the equation, all the terms on the left hand side are known values. The mean energy gradient ( \\bar{S_f} ) is computed from the mean of the velocity, depth, area, and hydraulic radius for the two sections. The friction slope can be computed using Manning's, Chezy, or the Darcy-Weisbach friction equations adapted for non-circular, free-surface conduits. The equation here is written moving upstream, direction matters for indexing. Thus position i+1 is assumed upstream of position i in this notebook. Such directional convention is unusual in numerical methods and analysts need to use care when developing their own tools or using other tools. A clever analyst need not rewrite code, but simple interchange of upstream and downstream depths can handle both backwater and front-water curves. Scripting an Algorithm Here the method is illustrated in to illustrate the tool as a programming environment. First we build a set of utility functions, these will be used later in the backwater function The listings below are utility functions for rectangular channels for flow area given channel depth and width and wetted perimeter given depth and width. Different geometries will need different functions (probably by numerical methods rather than actual functional relationships). The first listing is a depth-area function for rectangular geometry. # Depth-Area function for rectangular channel def area(depth,width): area=depth*width; return(area) The next listing is a depth wetted-perimeter function for a rectangular geometry. # Depth-Wetted perimeter function for rectangular channel def perimeter(depth,width): perimeter=2*depth+width; return(perimeter) Listing below is a listing of the code for the hydraulic radius (ratio of the above results), this is a generic function, it does not need to know the flow geometry # Hydraulic radius function def radius(area,perimeter): radius=area/perimeter; return(radius) The next section is a listing of code for the friction slope given Manning's n, discharge, hydraulic radius, and flow area. This function implicitly assumes SI units (the 1.49 constant in U.S. Customary units is not present). For U.S. Customary units either add the constant or convert the US units into equivalent SI units. # Friction slope function def slope_f(discharge,mannings_n,area,radius): slope_f=(discharge**2)*(mannings_n**2)/( (radius**(4./3))*(area**2) ); #compute friction slope return(slope_f) # 2-point average def avg2point(x1,x2): avg2point=0.5*(x1+x2); return(avg2point) The semi-colons in the functions are probably unnecessary, but have value because it forces the expression to its left to be evaluated and helps prevent ambiguous code. Also notice the use of indention as a scope delimiter, the delimiter is required. Describe the actual BW computes At this point, we have 5 useful, testable functions (and we should test before the next step. The next listing is the step-backwater method implemented as a function. This function computes the space steps, changes in depth, etc. as per the algorithm. The function is a FORTRAN port, so it is not a terribly efficient use of JupyterLab/iPython , but it illustrates count controlled repetition (for loops), array indexing, and use of the utility functions to make the code readable as well as ensure that the parts work before the whole program is assembled. This concept is really crucial, if you can build a tool of parts that are known to work, it helps keep logic errors contained to known locations. # Backwater curve function def backwater(begin_depth,end_depth,how_many,discharge,width,mannings_n,slope): # ## Example function call ## zz = backwater(begin_depth=8,end_depth=5,how_many=30,discharge=55.4,width=5,mannings_n=0.02,slope=0.001) ## Numerical values are values used in essay, they correspond to a particuar example from Koutitas 1983 # # Other functions must exist otherwise will spawn errors # # Prepare space for vectors twog=2.0*9.8 depth=[] # numeric vector for depths velocity=[] # numeric vector for velocities deltax=[] # numeric vector for spatial steps distance=[] # space for computing cumulative distances bse=[] # numeric vector for bottom elevations wse=[] # numeric vector for water surface elevations delta_depth=(begin_depth-end_depth)/(how_many) # change in depth for finding spatial steps #print(delta_depth) depth.append(begin_depth) # assign downstream value for i in range(1,how_many): depth.append(depth[0] - (i+1)*delta_depth) # uniform depths for i in range(0,how_many): velocity.append(discharge/area(depth[i],width)) for i in range(0,how_many-1): depth_bar=avg2point(depth[i+1],depth[i]); #compute average depth in reach area_bar=area(depth_bar,width); #compute average area in reach perimeter_bar=perimeter(depth_bar,width); #compute average wetted perimeter radius_bar=radius(area_bar,perimeter_bar); #compute average hydraulic radius friction=slope_f(discharge,mannings_n,area_bar,radius_bar) #compute friction slope snrgup =(depth[i+1]+((velocity[i+1]**2)/twog)) snrgdn =(depth[i] + ((velocity[i]**2)/twog)) step =(snrgup - snrgdn)/(slope-friction) # compute change in distance for each change in depth deltax.append(step) distance.append(0.0) bse.append(0.0) for i in range(1,how_many): distance.append(distance[i-1]+deltax[i-1]); # spatial distances bse.append(bse[i-1]-deltax[i-1]*slope); # bottom elevations for i in range(0,how_many): wse.append(bse[i]+depth[i]) # water surface elevations return(distance,wse,bse,depth,deltax,velocity) Example Backwater curve Figure 1 is a backwater curve for a rectangular channelwith discharge over a weir (on the right hand side \u2014 not depicted). The channel width is 5 meters, bottom slope 0.001, Manning\u2019s n = 0.02 and discharge Q = 55.4m^3/sec Using the backwater function and some plot calls in JupyterLab/iPython we can duplicate the figure (assuming the figure is essentially correct). Figure XX. Prismatic Rectangular Channel This example is adapted from: Page 85. Koutitas, C.G. (1983). Elements of Computational Hydraulics. Pentech Press, London 138p. ISBN 0-7273-0503-4 Function call with plotting # call the function - output is a tuple, use this fact in the plotting build output = backwater(begin_depth=8.0,end_depth=5.0,how_many=31,discharge=55.4,width=5.0,mannings_n=0.02,slope=0.001) # Now plot the water surface profile output ([0.0, -283.35036151530664, -428.01121940864573, -574.8515686316364, -724.0432559775297, -875.7784626846135, -1030.2730147587363, -1187.770394158555, -1348.5466367108593, -1512.9163627853982, -1681.2402702549975, -1853.9345367975611, -2031.4827466068946, -2214.451200843967, -2403.508832956717, -2599.4534970171985, -2803.247243443978, -3016.0645395117012, -3239.3595860271253, -3474.962585192671, -3725.221306601451, -3993.2161853820994, -4283.100097607726, -4600.660902930245, -4954.3084661830835, -5356.938830438938, -5829.813146361424, -6411.7849250248955, -7186.094269450929, -8389.539642756294, -11393.20102883886], [8.0, 8.089801974418533, 8.137688638763485, 8.187754794438089, 8.240172288235593, 8.29513330139429, 8.352853659920026, 8.413576845771459, 8.477578894775375, 8.545174427301527, 8.61672414122274, 8.692644214216916, 8.773418230477862, 8.859612491166548, 8.95189592973091, 9.051066400243004, 9.158085953121397, 9.274129055640733, 9.40064990860777, 9.539478714224929, 9.692963242085321, 9.864183927317583, 10.057293645994822, 10.278080257768956, 10.534953627473406, 10.840809798180874, 11.216909920554972, 11.702107505670057, 12.379642656547702, 13.486313836304682, 16.39320102883886], [0.0, 0.2833503615153066, 0.4280112194086457, 0.5748515686316364, 0.7240432559775297, 0.8757784626846135, 1.0302730147587362, 1.1877703941585551, 1.3485466367108594, 1.5129163627853983, 1.6812402702549976, 1.8539345367975613, 2.0314827466068945, 2.2144512008439667, 2.4035088329567165, 2.599453497017198, 2.8032472434439772, 3.0160645395117007, 3.2393595860271245, 3.474962585192671, 3.7252213066014503, 3.993216185382099, 4.283100097607726, 4.600660902930246, 4.954308466183084, 5.3569388304389385, 5.829813146361424, 6.411784925024896, 7.186094269450929, 8.389539642756294, 11.39320102883886], [8.0, 7.806451612903226, 7.709677419354839, 7.612903225806452, 7.516129032258064, 7.419354838709678, 7.32258064516129, 7.225806451612903, 7.129032258064516, 7.032258064516129, 6.935483870967742, 6.838709677419355, 6.741935483870968, 6.645161290322581, 6.548387096774194, 6.451612903225806, 6.35483870967742, 6.258064516129032, 6.161290322580645, 6.064516129032258, 5.967741935483871, 5.870967741935484, 5.774193548387097, 5.67741935483871, 5.580645161290322, 5.483870967741936, 5.387096774193548, 5.290322580645162, 5.193548387096774, 5.096774193548387, 5.0], [-283.35036151530664, -144.66085789333908, -146.84034922299065, -149.1916873458933, -151.7352067070838, -154.49455207412277, -157.49737939981884, -160.77624255230432, -164.36972607453902, -168.32390746959925, -172.6942665425636, -177.54820980933334, -182.96845423707217, -189.05763211274993, -195.9446640604816, -203.79374642677917, -212.81729606772353, -223.29504651542393, -235.60299916554615, -250.25872140877965, -267.99487878064855, -289.8839122256267, -317.5608053225197, -353.6475632528385, -402.63036425585443, -472.8743159224856, -581.971778663472, -774.3093444260335, -1203.4453733053651, -3003.661386082566], [1.385, 1.4193388429752065, 1.437154811715481, 1.4554237288135594, 1.4741630901287555, 1.493391304347826, 1.5131277533039649, 1.5333928571428572, 1.5542081447963803, 1.5755963302752292, 1.5975813953488371, 1.6201886792452829, 1.6434449760765548, 1.667378640776699, 1.6920197044334975, 1.7174, 1.7435532994923857, 1.7705154639175258, 1.798324607329843, 1.8270212765957448, 1.8566486486486486, 1.8872527472527472, 1.9188826815642457, 1.9515909090909087, 1.985433526011561, 2.020470588235294, 2.0567664670658683, 2.094390243902439, 2.133416149068323, 2.173924050632911, 2.2159999999999997]) import matplotlib.pyplot myfigure = matplotlib.pyplot.figure(figsize = (16,8)) # generate a object from the figure class, set aspect ratio # Built the plot matplotlib.pyplot.plot(output[0], output[2], color ='brown', linewidth=3) matplotlib.pyplot.plot(output[0], output[1], color ='blue', linewidth=5) matplotlib.pyplot.ylabel(\"Elevation (meters)\") matplotlib.pyplot.xlabel(\"Distance (meters)\") mytitle = \"Water Surface Profile - Variable Spatial Step Method\" matplotlib.pyplot.title(mytitle) matplotlib.pyplot.show() Matplotlib is building the font cache; this may take a moment. Fixed Spatial Step, Variable Depth The fixed-depth change, variable-space result is a useful tool, but not terribly practical because we mostly perform engineering hydraulics calculations to estimate values (depth, pressure, force) at prescribed locations in space, so we need another approach to the problem where we can prescribe the spatial locations, and solve for the depths. First the gradually varied flow equation is rearranged for relating the change in specific energy between two section to the spatial difference and the slope differences as \\begin{equation} \\Delta h_s = \\Delta (h + \\frac{V^2}{2g}) = \\Delta x (S_o - S_f) \\label{eqn:gvf-energy-bal} \\end{equation} The computation of h_{i+1},V_{i+1} from h_i,V_i is performed by iteration. An initial value for h_{i+1} that is known to be too large is used in the above Equation along with the known value of h_i to compute a trial value h_{s(i+1)} . Then the trial value is used in the right hand side of the Equation \\begin{equation} h_s = (h + \\frac{V^2}{2g}) \\label{eqn:gvf-energy-newl} \\end{equation} The two trial values are compared and the next value of h_{i+1} is computed by sucessively decreasing until the two values computed by the difference equation and the definition of specific energy coincide. The example below uses a method from Hamming to make the comparisons and adjust the guesses until they are sufficiently close enough. Example (Non-Prismatic Channel), Fixed Spatial Steps) A plan view of a rectangular channel of variable width as shown in Figure XX Figure XX. Non-Prismatic Rectangular Channel The channel conveys Q=100~m^3/sec , with a bottom slope of 0.001 and average Manning's n value of 0.033 . A backwater curve is caused by a weir at the downstream end (to the right in the figure) by a 7 meter tall weir. Flow depth over the weir is at critical depth h_c = 2.17 meters. Normal flow in the upstream portion for 10-meter channel width is h_n = 5.6 meters. Using the fixed space step method determine and plot a profile view of the water surface and channel bottom. The method employed is attributed to Hamming (cite and link to readings) that implements a Newton's-like method to match the left and right side of the difference equation. Here is our algorithm, first we set up some problem constants: # Hamming's Method for Backwater Curve imax = 30 #number of computational stations dx = -1000.0 #spacing between stations manningsN = 0.033 #mannings n value slopeChan = 0.001 #channel slope normalD = 5.6 #upstream station normal depth controlD = 9.17 #downstream station control depth discharge = 100.0 #steady discharge Next we define the plan view geometry, in this example we explicitly enter the values, but we could just as well read the geometry from a file to generalize the script. topwidth = [10,10,10,11,12,13,14,13,12,11,10,9,8,7,8,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10] topwidth = [float(i) for i in topwidth] # use of range() to set indices With topwidth defined, we can compute values of velocity at the control section (downstream pool in the example). The conrtol section has position 0 in the various lists within our script. Observe the two ways we can populate the vectors with constants, use whichever you fancy! velo = [0] * imax # allocate a velocity vector, put zeroes everywhere velo[0] = discharge/topwidth[0]/controlD #set velocity at control section depth = [0 for i in range(0,imax)] # allocate a depth vector, put zeroes everywhere spDepth = [0 for i in range(0,imax)] # allocate a sp. depth vector, put zeroes everywhere spDepthT = [0 for i in range(0,imax)] # allocate a sp. depth vector, put zeroes everywhere Now set control section depth, and specific energy depth[0] = controlD # set control section depth spDepth[0] = ((velo[0]**2)/(2.0*9.81)) + depth[0] Now we implement the algorithm, starting from section 1 (just upstream of the control section) we use the difference equation and Hamming's method to find a value of depth that satisfies the difference equation. Here are three loops, an outer one that processes each section and two inner loops that perform the balancing act - notice how the script breaks from a loop, when the conditions are satisfied. ## begin for loop for i in range(1,imax): depth[i] = 10 difn = 1.0 dh = 1.0 ### begin do while loop 1 while (dh > 0.0001): dif = difn ntest = 0 depth[i] = depth[i]-dh #### begin do while loop 2 while (dh > 0): velo[i] =discharge/topwidth[i]/depth[i] avgDepth = 0.5*(depth[i-1]+depth[i]) avgTopW = 0.5*(topwidth[i-1]+topwidth[i]) avgV = discharge/avgTopW/avgDepth hydR = avgDepth*avgTopW/(avgTopW+2.0*avgDepth) sFric = (avgV**2)*(manningsN**2)/(hydR**(1.33)) spDepth[i] = spDepth[i-1]+(slopeChan-sFric)*dx spDepthT[i] = depth[i]+(velo[i]**2/(2.0*9.81)) difn = spDepthT[i]-spDepth[i] if(ntest > 0): dh = dh/10.0 break #break from do while loop 2 if(dif*difn > 0): break #break from do while loop 2 depth[i] = depth[i] + dh ntest = 1 #### end do while loop 2 ### end do while loop 1 ## end for loop Now we prepare the output for plotting distance = [0]*imax bottom = [0]*imax watersurface = [0]*imax for i in range(1,imax): distance[i] = distance[i-1]+dx bottom[i] = -distance[i]*slopeChan watersurface[i] = depth[i]+bottom[i] watersurface[0] = depth[0]+bottom[0] # don't forget the control section! Here we just reuse the plotting methods from prior lessons, but substitute in the correct vector names # Now plot the water surface profile import matplotlib.pyplot myfigure = matplotlib.pyplot.figure(figsize = (16,8)) # generate a object from the figure class, set aspect ratio # Built the plot matplotlib.pyplot.plot(distance, bottom, color ='brown', linewidth=3) matplotlib.pyplot.plot(distance, watersurface, color ='blue', linewidth=5) matplotlib.pyplot.ylabel(\"Elevation (meters)\") matplotlib.pyplot.xlabel(\"Distance (meters)\") mytitle = \"Water Surface Profile - Fixed Spatial Step Method\" matplotlib.pyplot.title(mytitle) matplotlib.pyplot.show() SWMM Now we will do the same simulation in SWMM - we will find it is a lot easier to set-up and run. The useful trick is to use the Dynamic Wave Routing, but run the simulation to equilibrium; the other hydraulic routing methods in SWMM are unsuitable for this particular problem. References Koutitas, C. G. 1983. Elements of Computational Hydraulics. ISBN 0-412-00361-9. Pentech Press Ltd. London. (Chapter 4) http://54.243.252.9/ce-5362-psuedo-course/3-Readings/PracticalComputationalHydraulics-Kousitas/ElementsOfComputationalHydraulics.pdf Roberson, J. A., Cassidy, J.J., and Chaudry, M. H., (1988) Hydraulic Engineering, Houghton Mifflin Co (Chapter 10) http://54.243.252.9/ce-5362-psuedo-course/3-Readings/HydraulicEngineering/ Sturm T.W (2001) Open Channel Hydraulics, 1ed., McGraw-Hill, New York. Note: This PDF is from an international edition published in Singapore. http://54.243.252.9/ce-5362-psuedo-course/3-Readings/OpenChannelHYdraulics/ Cunge, J.A., Holly, F.M., Verwey, A. (1980). Practical Aspects of Computational River Hydraulics. Pittman Publishing Inc. , Boston, MA. pp. 7-50","title":"Lesson 6 GVF Fixed Step-Backwater"},{"location":"lesson6/ce5362-swmodeling-lesson-6/#ce-5362-lesson-6-computational-workshop","text":"This computational workshop is to examine computation related to: Uniform flow; algebraic equation. S_f = S_0 Gradually varied; ordinary differential equation. S_f = S_0 - \\frac{\\partial z}{\\partial x} - \\frac{V}{g}\\frac{\\partial V}{\\partial x} Dynamic flow (shallow wave) conditions; partial differential equation. S_f = S_0 - \\frac{1}{g} \\frac{\\partial V}{\\partial t} - \\frac{\\partial z}{\\partial x} - \\frac{V}{g}\\frac{\\partial V}{\\partial x} The objectives are to explore the JupyterLab environment to make relevant computations, then compare results to the professional tools (SWMM)","title":"CE 5362 Lesson 6 Computational Workshop"},{"location":"lesson6/ce5362-swmodeling-lesson-6/#gradually-varied-steady-flow","text":"","title":"Gradually Varied Steady Flow"},{"location":"lesson6/ce5362-swmodeling-lesson-6/#fixed-depth-change-variable-spatial-step","text":"The fixed-step refers to specified changes in depth for which we solve to find the variable spatial steps. The method is a very simple method for computing water surface profiles in prismatic channels. A prismatic channel is a channel of uniform cross sectional geometry with constant bed (topographic) slope. In such channels with smooth (non-jump) steady flow the continunity and momentum equations are: Q = AV where where Q is volumetric discharge, A is cross sectional flow area, and V is the mean section velocity; and: \\frac{V}{g} \\frac{dV}{dx}+\\frac{dh}{dx} = S_o - S_f where h is the flow depth (above the bottom), and x is horizontal the distance along the channel. For the variable step method, the momentum equation is rewritten as a difference equation (after application of calculus to gather terms) then rearranged to solve for the spatial step dimension . \\frac{\\frac{V^2_{i+1}}{2g}-\\frac{V^2_{i}}{2g}}{\\Delta x} + \\frac{h_{i+1}-h_{i}}{\\Delta x} = S_o - \\bar{S_f} where S_f is the average slope of the energy grade line between two sections (along a reach of length \\Delta x , the unknown value). Rearrangement to isolate \\Delta x produces an explicit update equation that can be evaluated to find the different values of \\Delta x associated with different flow depths. The plot of the accumulated spatial changes versus the sum of the flow depth and bottom elevation is the water surface profile. \\frac{(h_{i+1} + \\frac{V^2_{i+1}}{2g}) - (h_{i} +\\frac{V^2_{i}}{2g}) }{S_o - \\bar{S_f} } = \\Delta x The distance between two sections with known discharges is computed using the equation, all the terms on the left hand side are known values. The mean energy gradient ( \\bar{S_f} ) is computed from the mean of the velocity, depth, area, and hydraulic radius for the two sections. The friction slope can be computed using Manning's, Chezy, or the Darcy-Weisbach friction equations adapted for non-circular, free-surface conduits. The equation here is written moving upstream, direction matters for indexing. Thus position i+1 is assumed upstream of position i in this notebook. Such directional convention is unusual in numerical methods and analysts need to use care when developing their own tools or using other tools. A clever analyst need not rewrite code, but simple interchange of upstream and downstream depths can handle both backwater and front-water curves.","title":"Fixed Depth Change, Variable Spatial Step"},{"location":"lesson6/ce5362-swmodeling-lesson-6/#scripting-an-algorithm","text":"Here the method is illustrated in to illustrate the tool as a programming environment. First we build a set of utility functions, these will be used later in the backwater function The listings below are utility functions for rectangular channels for flow area given channel depth and width and wetted perimeter given depth and width. Different geometries will need different functions (probably by numerical methods rather than actual functional relationships). The first listing is a depth-area function for rectangular geometry. # Depth-Area function for rectangular channel def area(depth,width): area=depth*width; return(area) The next listing is a depth wetted-perimeter function for a rectangular geometry. # Depth-Wetted perimeter function for rectangular channel def perimeter(depth,width): perimeter=2*depth+width; return(perimeter) Listing below is a listing of the code for the hydraulic radius (ratio of the above results), this is a generic function, it does not need to know the flow geometry # Hydraulic radius function def radius(area,perimeter): radius=area/perimeter; return(radius) The next section is a listing of code for the friction slope given Manning's n, discharge, hydraulic radius, and flow area. This function implicitly assumes SI units (the 1.49 constant in U.S. Customary units is not present). For U.S. Customary units either add the constant or convert the US units into equivalent SI units. # Friction slope function def slope_f(discharge,mannings_n,area,radius): slope_f=(discharge**2)*(mannings_n**2)/( (radius**(4./3))*(area**2) ); #compute friction slope return(slope_f) # 2-point average def avg2point(x1,x2): avg2point=0.5*(x1+x2); return(avg2point) The semi-colons in the functions are probably unnecessary, but have value because it forces the expression to its left to be evaluated and helps prevent ambiguous code. Also notice the use of indention as a scope delimiter, the delimiter is required.","title":"Scripting an Algorithm"},{"location":"lesson6/ce5362-swmodeling-lesson-6/#describe-the-actual-bw-computes","text":"At this point, we have 5 useful, testable functions (and we should test before the next step. The next listing is the step-backwater method implemented as a function. This function computes the space steps, changes in depth, etc. as per the algorithm. The function is a FORTRAN port, so it is not a terribly efficient use of JupyterLab/iPython , but it illustrates count controlled repetition (for loops), array indexing, and use of the utility functions to make the code readable as well as ensure that the parts work before the whole program is assembled. This concept is really crucial, if you can build a tool of parts that are known to work, it helps keep logic errors contained to known locations. # Backwater curve function def backwater(begin_depth,end_depth,how_many,discharge,width,mannings_n,slope): # ## Example function call ## zz = backwater(begin_depth=8,end_depth=5,how_many=30,discharge=55.4,width=5,mannings_n=0.02,slope=0.001) ## Numerical values are values used in essay, they correspond to a particuar example from Koutitas 1983 # # Other functions must exist otherwise will spawn errors # # Prepare space for vectors twog=2.0*9.8 depth=[] # numeric vector for depths velocity=[] # numeric vector for velocities deltax=[] # numeric vector for spatial steps distance=[] # space for computing cumulative distances bse=[] # numeric vector for bottom elevations wse=[] # numeric vector for water surface elevations delta_depth=(begin_depth-end_depth)/(how_many) # change in depth for finding spatial steps #print(delta_depth) depth.append(begin_depth) # assign downstream value for i in range(1,how_many): depth.append(depth[0] - (i+1)*delta_depth) # uniform depths for i in range(0,how_many): velocity.append(discharge/area(depth[i],width)) for i in range(0,how_many-1): depth_bar=avg2point(depth[i+1],depth[i]); #compute average depth in reach area_bar=area(depth_bar,width); #compute average area in reach perimeter_bar=perimeter(depth_bar,width); #compute average wetted perimeter radius_bar=radius(area_bar,perimeter_bar); #compute average hydraulic radius friction=slope_f(discharge,mannings_n,area_bar,radius_bar) #compute friction slope snrgup =(depth[i+1]+((velocity[i+1]**2)/twog)) snrgdn =(depth[i] + ((velocity[i]**2)/twog)) step =(snrgup - snrgdn)/(slope-friction) # compute change in distance for each change in depth deltax.append(step) distance.append(0.0) bse.append(0.0) for i in range(1,how_many): distance.append(distance[i-1]+deltax[i-1]); # spatial distances bse.append(bse[i-1]-deltax[i-1]*slope); # bottom elevations for i in range(0,how_many): wse.append(bse[i]+depth[i]) # water surface elevations return(distance,wse,bse,depth,deltax,velocity)","title":"Describe the actual BW computes"},{"location":"lesson6/ce5362-swmodeling-lesson-6/#example-backwater-curve","text":"Figure 1 is a backwater curve for a rectangular channelwith discharge over a weir (on the right hand side \u2014 not depicted). The channel width is 5 meters, bottom slope 0.001, Manning\u2019s n = 0.02 and discharge Q = 55.4m^3/sec Using the backwater function and some plot calls in JupyterLab/iPython we can duplicate the figure (assuming the figure is essentially correct). Figure XX. Prismatic Rectangular Channel This example is adapted from: Page 85. Koutitas, C.G. (1983). Elements of Computational Hydraulics. Pentech Press, London 138p. ISBN 0-7273-0503-4","title":"Example Backwater curve"},{"location":"lesson6/ce5362-swmodeling-lesson-6/#function-call-with-plotting","text":"# call the function - output is a tuple, use this fact in the plotting build output = backwater(begin_depth=8.0,end_depth=5.0,how_many=31,discharge=55.4,width=5.0,mannings_n=0.02,slope=0.001) # Now plot the water surface profile output ([0.0, -283.35036151530664, -428.01121940864573, -574.8515686316364, -724.0432559775297, -875.7784626846135, -1030.2730147587363, -1187.770394158555, -1348.5466367108593, -1512.9163627853982, -1681.2402702549975, -1853.9345367975611, -2031.4827466068946, -2214.451200843967, -2403.508832956717, -2599.4534970171985, -2803.247243443978, -3016.0645395117012, -3239.3595860271253, -3474.962585192671, -3725.221306601451, -3993.2161853820994, -4283.100097607726, -4600.660902930245, -4954.3084661830835, -5356.938830438938, -5829.813146361424, -6411.7849250248955, -7186.094269450929, -8389.539642756294, -11393.20102883886], [8.0, 8.089801974418533, 8.137688638763485, 8.187754794438089, 8.240172288235593, 8.29513330139429, 8.352853659920026, 8.413576845771459, 8.477578894775375, 8.545174427301527, 8.61672414122274, 8.692644214216916, 8.773418230477862, 8.859612491166548, 8.95189592973091, 9.051066400243004, 9.158085953121397, 9.274129055640733, 9.40064990860777, 9.539478714224929, 9.692963242085321, 9.864183927317583, 10.057293645994822, 10.278080257768956, 10.534953627473406, 10.840809798180874, 11.216909920554972, 11.702107505670057, 12.379642656547702, 13.486313836304682, 16.39320102883886], [0.0, 0.2833503615153066, 0.4280112194086457, 0.5748515686316364, 0.7240432559775297, 0.8757784626846135, 1.0302730147587362, 1.1877703941585551, 1.3485466367108594, 1.5129163627853983, 1.6812402702549976, 1.8539345367975613, 2.0314827466068945, 2.2144512008439667, 2.4035088329567165, 2.599453497017198, 2.8032472434439772, 3.0160645395117007, 3.2393595860271245, 3.474962585192671, 3.7252213066014503, 3.993216185382099, 4.283100097607726, 4.600660902930246, 4.954308466183084, 5.3569388304389385, 5.829813146361424, 6.411784925024896, 7.186094269450929, 8.389539642756294, 11.39320102883886], [8.0, 7.806451612903226, 7.709677419354839, 7.612903225806452, 7.516129032258064, 7.419354838709678, 7.32258064516129, 7.225806451612903, 7.129032258064516, 7.032258064516129, 6.935483870967742, 6.838709677419355, 6.741935483870968, 6.645161290322581, 6.548387096774194, 6.451612903225806, 6.35483870967742, 6.258064516129032, 6.161290322580645, 6.064516129032258, 5.967741935483871, 5.870967741935484, 5.774193548387097, 5.67741935483871, 5.580645161290322, 5.483870967741936, 5.387096774193548, 5.290322580645162, 5.193548387096774, 5.096774193548387, 5.0], [-283.35036151530664, -144.66085789333908, -146.84034922299065, -149.1916873458933, -151.7352067070838, -154.49455207412277, -157.49737939981884, -160.77624255230432, -164.36972607453902, -168.32390746959925, -172.6942665425636, -177.54820980933334, -182.96845423707217, -189.05763211274993, -195.9446640604816, -203.79374642677917, -212.81729606772353, -223.29504651542393, -235.60299916554615, -250.25872140877965, -267.99487878064855, -289.8839122256267, -317.5608053225197, -353.6475632528385, -402.63036425585443, -472.8743159224856, -581.971778663472, -774.3093444260335, -1203.4453733053651, -3003.661386082566], [1.385, 1.4193388429752065, 1.437154811715481, 1.4554237288135594, 1.4741630901287555, 1.493391304347826, 1.5131277533039649, 1.5333928571428572, 1.5542081447963803, 1.5755963302752292, 1.5975813953488371, 1.6201886792452829, 1.6434449760765548, 1.667378640776699, 1.6920197044334975, 1.7174, 1.7435532994923857, 1.7705154639175258, 1.798324607329843, 1.8270212765957448, 1.8566486486486486, 1.8872527472527472, 1.9188826815642457, 1.9515909090909087, 1.985433526011561, 2.020470588235294, 2.0567664670658683, 2.094390243902439, 2.133416149068323, 2.173924050632911, 2.2159999999999997]) import matplotlib.pyplot myfigure = matplotlib.pyplot.figure(figsize = (16,8)) # generate a object from the figure class, set aspect ratio # Built the plot matplotlib.pyplot.plot(output[0], output[2], color ='brown', linewidth=3) matplotlib.pyplot.plot(output[0], output[1], color ='blue', linewidth=5) matplotlib.pyplot.ylabel(\"Elevation (meters)\") matplotlib.pyplot.xlabel(\"Distance (meters)\") mytitle = \"Water Surface Profile - Variable Spatial Step Method\" matplotlib.pyplot.title(mytitle) matplotlib.pyplot.show() Matplotlib is building the font cache; this may take a moment.","title":"Function call with plotting"},{"location":"lesson6/ce5362-swmodeling-lesson-6/#fixed-spatial-step-variable-depth","text":"The fixed-depth change, variable-space result is a useful tool, but not terribly practical because we mostly perform engineering hydraulics calculations to estimate values (depth, pressure, force) at prescribed locations in space, so we need another approach to the problem where we can prescribe the spatial locations, and solve for the depths. First the gradually varied flow equation is rearranged for relating the change in specific energy between two section to the spatial difference and the slope differences as \\begin{equation} \\Delta h_s = \\Delta (h + \\frac{V^2}{2g}) = \\Delta x (S_o - S_f) \\label{eqn:gvf-energy-bal} \\end{equation} The computation of h_{i+1},V_{i+1} from h_i,V_i is performed by iteration. An initial value for h_{i+1} that is known to be too large is used in the above Equation along with the known value of h_i to compute a trial value h_{s(i+1)} . Then the trial value is used in the right hand side of the Equation \\begin{equation} h_s = (h + \\frac{V^2}{2g}) \\label{eqn:gvf-energy-newl} \\end{equation} The two trial values are compared and the next value of h_{i+1} is computed by sucessively decreasing until the two values computed by the difference equation and the definition of specific energy coincide. The example below uses a method from Hamming to make the comparisons and adjust the guesses until they are sufficiently close enough.","title":"Fixed Spatial Step, Variable Depth"},{"location":"lesson6/ce5362-swmodeling-lesson-6/#example-non-prismatic-channel-fixed-spatial-steps","text":"A plan view of a rectangular channel of variable width as shown in Figure XX Figure XX. Non-Prismatic Rectangular Channel The channel conveys Q=100~m^3/sec , with a bottom slope of 0.001 and average Manning's n value of 0.033 . A backwater curve is caused by a weir at the downstream end (to the right in the figure) by a 7 meter tall weir. Flow depth over the weir is at critical depth h_c = 2.17 meters. Normal flow in the upstream portion for 10-meter channel width is h_n = 5.6 meters. Using the fixed space step method determine and plot a profile view of the water surface and channel bottom. The method employed is attributed to Hamming (cite and link to readings) that implements a Newton's-like method to match the left and right side of the difference equation. Here is our algorithm, first we set up some problem constants: # Hamming's Method for Backwater Curve imax = 30 #number of computational stations dx = -1000.0 #spacing between stations manningsN = 0.033 #mannings n value slopeChan = 0.001 #channel slope normalD = 5.6 #upstream station normal depth controlD = 9.17 #downstream station control depth discharge = 100.0 #steady discharge Next we define the plan view geometry, in this example we explicitly enter the values, but we could just as well read the geometry from a file to generalize the script. topwidth = [10,10,10,11,12,13,14,13,12,11,10,9,8,7,8,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10] topwidth = [float(i) for i in topwidth] # use of range() to set indices With topwidth defined, we can compute values of velocity at the control section (downstream pool in the example). The conrtol section has position 0 in the various lists within our script. Observe the two ways we can populate the vectors with constants, use whichever you fancy! velo = [0] * imax # allocate a velocity vector, put zeroes everywhere velo[0] = discharge/topwidth[0]/controlD #set velocity at control section depth = [0 for i in range(0,imax)] # allocate a depth vector, put zeroes everywhere spDepth = [0 for i in range(0,imax)] # allocate a sp. depth vector, put zeroes everywhere spDepthT = [0 for i in range(0,imax)] # allocate a sp. depth vector, put zeroes everywhere Now set control section depth, and specific energy depth[0] = controlD # set control section depth spDepth[0] = ((velo[0]**2)/(2.0*9.81)) + depth[0] Now we implement the algorithm, starting from section 1 (just upstream of the control section) we use the difference equation and Hamming's method to find a value of depth that satisfies the difference equation. Here are three loops, an outer one that processes each section and two inner loops that perform the balancing act - notice how the script breaks from a loop, when the conditions are satisfied. ## begin for loop for i in range(1,imax): depth[i] = 10 difn = 1.0 dh = 1.0 ### begin do while loop 1 while (dh > 0.0001): dif = difn ntest = 0 depth[i] = depth[i]-dh #### begin do while loop 2 while (dh > 0): velo[i] =discharge/topwidth[i]/depth[i] avgDepth = 0.5*(depth[i-1]+depth[i]) avgTopW = 0.5*(topwidth[i-1]+topwidth[i]) avgV = discharge/avgTopW/avgDepth hydR = avgDepth*avgTopW/(avgTopW+2.0*avgDepth) sFric = (avgV**2)*(manningsN**2)/(hydR**(1.33)) spDepth[i] = spDepth[i-1]+(slopeChan-sFric)*dx spDepthT[i] = depth[i]+(velo[i]**2/(2.0*9.81)) difn = spDepthT[i]-spDepth[i] if(ntest > 0): dh = dh/10.0 break #break from do while loop 2 if(dif*difn > 0): break #break from do while loop 2 depth[i] = depth[i] + dh ntest = 1 #### end do while loop 2 ### end do while loop 1 ## end for loop Now we prepare the output for plotting distance = [0]*imax bottom = [0]*imax watersurface = [0]*imax for i in range(1,imax): distance[i] = distance[i-1]+dx bottom[i] = -distance[i]*slopeChan watersurface[i] = depth[i]+bottom[i] watersurface[0] = depth[0]+bottom[0] # don't forget the control section! Here we just reuse the plotting methods from prior lessons, but substitute in the correct vector names # Now plot the water surface profile import matplotlib.pyplot myfigure = matplotlib.pyplot.figure(figsize = (16,8)) # generate a object from the figure class, set aspect ratio # Built the plot matplotlib.pyplot.plot(distance, bottom, color ='brown', linewidth=3) matplotlib.pyplot.plot(distance, watersurface, color ='blue', linewidth=5) matplotlib.pyplot.ylabel(\"Elevation (meters)\") matplotlib.pyplot.xlabel(\"Distance (meters)\") mytitle = \"Water Surface Profile - Fixed Spatial Step Method\" matplotlib.pyplot.title(mytitle) matplotlib.pyplot.show()","title":"Example (Non-Prismatic Channel), Fixed Spatial Steps)"},{"location":"lesson6/ce5362-swmodeling-lesson-6/#swmm","text":"Now we will do the same simulation in SWMM - we will find it is a lot easier to set-up and run. The useful trick is to use the Dynamic Wave Routing, but run the simulation to equilibrium; the other hydraulic routing methods in SWMM are unsuitable for this particular problem.","title":"SWMM"},{"location":"lesson6/ce5362-swmodeling-lesson-6/#references","text":"Koutitas, C. G. 1983. Elements of Computational Hydraulics. ISBN 0-412-00361-9. Pentech Press Ltd. London. (Chapter 4) http://54.243.252.9/ce-5362-psuedo-course/3-Readings/PracticalComputationalHydraulics-Kousitas/ElementsOfComputationalHydraulics.pdf Roberson, J. A., Cassidy, J.J., and Chaudry, M. H., (1988) Hydraulic Engineering, Houghton Mifflin Co (Chapter 10) http://54.243.252.9/ce-5362-psuedo-course/3-Readings/HydraulicEngineering/ Sturm T.W (2001) Open Channel Hydraulics, 1ed., McGraw-Hill, New York. Note: This PDF is from an international edition published in Singapore. http://54.243.252.9/ce-5362-psuedo-course/3-Readings/OpenChannelHYdraulics/ Cunge, J.A., Holly, F.M., Verwey, A. (1980). Practical Aspects of Computational River Hydraulics. Pittman Publishing Inc. , Boston, MA. pp. 7-50","title":"References"}]}